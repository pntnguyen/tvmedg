---
title: "tvmedg package"
format:
  html:
    page-layout: full
    code-fold: show
    code-tools: true
editor: visual
message: false
warning: false
---

```{r}
library(tidyverse)
library(magrittr)
library(testthat)
```

# Import data

```{r}
dat0 <- readRDS("../Data/tvmed_dat100.RDS")
dat0 %>% as.data.frame() %>% head()
```

# df_prep function

```{r}
df_prep <- function(data) {
  
  df <- data.frame(id = data$id)
  
  # Baseline characteristics
  df$v1 <- data$age
  df$v2 <- data$sex
  df$v3 <- data$ow
  df$v4 <- data$risk
  
  
  # Time-varying treatment
  df$A <- data$Ap
  df$Al1 <- data$A_lag1
  df$Al2 <- data$A_lag2
  
  
  # time-dependent covariate
  df$T1 <- data$L1
  df$T1l1 <- data$L1_lag1
  df$T1l2 <- data$L1_lag2
  
  df$T2 <- data$L2
  df$T2l1 <- data$L2_lag1
  df$T2l2 <- data$L2_lag2
  
  df$T3 <- data$L3
  df$T3l1 <- data$L3_lag1
  df$T3l2 <- data$L3_lag2

  # Mediator
  df$M1 <- data$Mp
  df$M1l1 <- data$M_lag1
  df$M1l2 <- data$M_lag2
  
  # outcomes
  df$Y <- data$Yp
  
  # Time
  df$j <- data$mm
  
  return(df)
}
```

# Process data function

Function này gồm các argument mà user sẽ nhập vào gồm **fix**: time_fixed covariates, **expo**: exposure variable, **med**: mediator variables, **lag**: lag, **outc**: outcome variable, **data**: data

Khi sử dụng function này user sẽ nhập các variables và outcome sẽ trả về theo lag

```{r}
process_data <- function(fix,expo,med,tvar,lag,outc,time,data){

  ## column names of time-fixed variables
  name_v <- paste0("v",1:length(fix))
  
  out <- data.frame(id = data$id) %>% 
    mutate(data[,fix]) %>% 
    magrittr::set_colnames(c("id",name_v))
  
  ## column names of exposure variables  
  name_e <- paste0("A",1:length(expo))
  
  ## column names of mediator variables  
  name_me <- paste0("M",1:length(med))
  
  ## column names of time-varying variables  
  name_tvar <- paste0("L",1:length(tvar))
  
  
  for (i in 1:lag){
    
    ## column name of lag effect on exposure variable
    co_ex <- paste0(name_e,"l",i)
    co_me <- paste0(name_me,"l",i)
    co_tvar <- paste0(name_tvar,"l",i)
    
    for (k in 1:length(name_e)){
      
    out[,name_e[k]] <- data[,expo[k]]
    name_ep <- {{co_ex}}[k]
    out <- out %>% 
    group_by(id) %>% 
    mutate(
        {{name_ep}} := lag(!!sym(name_e[k]),n=i,default = data[1,expo[k]])
      )
    
    } 
    
    for (k in 1:length(name_me)){

    out[,name_me[k]] <- data[,med[k]]
    name_med <- {{co_me}}[k]
    out <- out %>% 
      group_by(id) %>% 
      mutate(
        {{name_med}} := lag(!!sym(name_me[k]),n=i,default = data[1,med[k]])
      ) 
      
    }  
    
    for (k in 1:length(name_tvar)){
    
    out[,name_tvar[k]] <- data[,tvar[k]]
    name_tv <- {{co_tvar}}[k]
    out <- out %>% 
      group_by(id) %>% 
      mutate(
        {{name_tv}} := lag(!!sym(name_tvar[k]),n=i,default = data[1,tvar[k]])
      )
      
    }
    
    
  }
  
  ## outcome variable
  out$Y <- data[,outc]
  
  ## time variable
  out$j <- data[,time]
  
  out %>% data.frame()
  
}  
```

## Comparison

::: columns
::: {.column width="50%"}

a Long's code

```{r}
dat <- dat0 |> 
    group_by(id) |>
    mutate(
      A_lag1 = lag(Ap, n = 1, default = 0),
      A_lag2 = lag(Ap, n = 2, default = 0),
      M_lag1 = lag(Mp, n = 1, default = 0),
      M_lag2 = lag(Mp, n = 2, default = 0),
      L1_lag1 = lag(L1, n = 1, default = 0),
      L1_lag2 = lag(L1, n = 2, default = 0),
      L2_lag1 = lag(L2, n = 1, default = 100),
      L2_lag2 = lag(L2, n = 2, default = 100),
      L3_lag1 = lag(L3, n = 1, default = 80),
      L3_lag2 = lag(L3, n = 2, default = 80)
    ) |> ungroup() %>% df_prep()

dat %>% head()
```


:::

::: {.column width="50%"}

Function

```{r}
## example lag = 3
data_pro <- process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) 

data_pro %>% head()
```

:::
:::

## Test

```{r}
test_that("process_data function", {
  ## id, v1 - v4
  expect_equal(dat[,c(1:5)],data_pro[,c(1:5)])
  
  ## exposure variables
  expect_equal(dat[,c("A")],data_pro[,c("A1")])
  expect_equal(dat[,c("Al1")],data_pro[,c("A1l1")])
  expect_equal(dat[,c("Al2")],data_pro[,c("A1l2")])
  
  ## time-dependent covariate
  expect_equal(dat[,c("T1")],data_pro[,c("L1")])
  expect_equal(dat[,c("T2")],data_pro[,c("L2")])
  expect_equal(dat[,c("T3")],data_pro[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(dat[,c("T1l1")],data_pro[,c("L1l1")])
  expect_equal(dat[,c("T2l1")],data_pro[,c("L2l1")])
  expect_equal(dat[,c("T3l1")],data_pro[,c("L3l1")])

  expect_equal(dat[,c("T1l2")],data_pro[,c("L1l2")])
  expect_equal(dat[,c("T2l2")],data_pro[,c("L2l2")])
  expect_equal(dat[,c("T3l2")],data_pro[,c("L3l2")])

  ## Mediator
  expect_equal(dat[,c("M1")],data_pro[,c("M1")])
  expect_equal(dat[,c("M1l1")],data_pro[,c("M1l1")])
  expect_equal(dat[,c("M1l2")],data_pro[,c("M1l2")])

  ## outcome and time
  expect_equal(dat[,c("Y","j")],data_pro[,c("Y","j")])
  
})
```

### Another example

```{r}
## lag = 3
process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 3,
    time = c("mm"),
    data = dat0
  ) %>% head()

```

```{r}
## assump risk is another exposure variables

## This time, risk become A2 variable
process_data(
    fix = c("age","sex","ow"),
    expo = c("Ap","risk"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) %>% head()

```

```{r}
## assump exposure is continuous variables, in this case is L3

process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap","L3"),
    med = c("Mp"),
    tvar = c("L1","L2"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) %>% head()

```

# Function to centering and scaling the time-scale variable

```{r}
cen_and_scale <- function(time){
  
  j_out <- list()
  
  jj <- time %>% 
        scale() 
  
  j_out[["jj"]] <- jj %>% as.numeric()
  j_out[["mean_j"]] <- attributes(jj)$`scaled:center`
  j_out[["sd_j"]] <- attributes(jj)$`scaled:scale`
  
  j_out
}
```

::: columns
::: {.column width="50%"}

```{r}
## Assump seed = 0, not doing boostrap

boot <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)

```

:::

::: {.column width="50%"}

```{r}
boot2 <- cen_and_scale(data_pro$j)
```


:::
:::

### Test

```{r}
test_that("cen and scale function", {
  expect_equal(boot$jj,boot2$jj)
  expect_equal(mean_j,boot2$mean_j)
  expect_equal(sd_j,boot2$sd_j)
})
```

# write formula function

Assumption ở bước này là sau khi data đã được process và tên các column đã được thống nhất theo tiêu chuẩn chung của package. Khúc này em chưa viết function chỉ viết các lệnh lẻ để thể hiện workflow của function

Em đang bị stuck ở:

  -   Em chưa viết được formula cho L(t), do L1 không bao gồm L2+L3, L2 thì bao gồm L1, và L3 bao gồm L1+L2. Em chưa tìm ra được quy luật để viết
  
  -   Phần splines phía sau sẽ để user define degree of freedom và paste vào trong formula, nhưng em chưa làm để đỡ rối  

```{r}
eps <- data_pro %>% select(starts_with("A")) %>% colnames()
tf <- data_pro %>% select(starts_with("v")) %>% colnames()
tva <- data_pro %>% select(starts_with("L")) %>% colnames()
mediator <- data_pro %>% select(starts_with("M")) %>% colnames()
outcome <- data_pro %>% select(starts_with("Y")) %>% colnames()
timee <- data_pro %>% select(starts_with("j")) %>% colnames()
```

```{r}
## assump các arguments này được input vào function data_processed 
fix = c("age","sex","ow","risk")
expo = c("Ap")
med = c("Mp")
tvar = c("L1","L2","L3")
outc = c("Yp")
lag = 2
time = c("mm")

## column names of exposure variables
name_e <- paste0("A",1:length(expo))

## column names of mediator variables  
name_me <- paste0("M",1:length(med))

## column names of time-varying variables  
name_tvar <- paste0("L",1:length(tvar))

```

## Formula for M(t)

```{r}
## formula for M(t)
# l(t-1)
l_tm1 <- tva[!tva %in% name_tvar]
l_tm1

formular_mt <- paste(mediator[1],"~",paste(c(eps,mediator[-1],l_tm1,tf),collapse = " + "))
formular_mt
```

### Test

Assump chưa bao gồm j

```{r}
test_that("test data formular for M(t)", {
  
  ## a Long code

  boot <- dat0 |> 
    group_by(id) |>
    mutate(
      A_lag1 = lag(Ap, n = 1, default = 0),
      A_lag2 = lag(Ap, n = 2, default = 0),
      M_lag1 = lag(Mp, n = 1, default = 0),
      M_lag2 = lag(Mp, n = 2, default = 0),
      L1_lag1 = lag(L1, n = 1, default = 0),
      L1_lag2 = lag(L1, n = 2, default = 0),
      L2_lag1 = lag(L2, n = 1, default = 100),
      L2_lag2 = lag(L2, n = 2, default = 100),
      L3_lag1 = lag(L3, n = 1, default = 80),
      L3_lag2 = lag(L3, n = 2, default = 80)
    ) |> ungroup() %>% df_prep()
  
  aLong_model <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                      v1 + v2 + v3 + v4, family = binomial, data = boot)|>
    suppressWarnings()
  
  ## Nguyen's code
  
  data_pro <- process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) 
  
  N_model <- glm(formular_mt ,family = binomial, data = data_pro) |>
    suppressWarnings()
  
  expect_equal(min(N_model$fitted.values),min(aLong_model$fitted.values))
  expect_equal(max(N_model$fitted.values),max(aLong_model$fitted.values))
  expect_equal(mean(N_model$fitted.values),mean(aLong_model$fitted.values))
  expect_equal(sd(N_model$fitted.values),sd(aLong_model$fitted.values))
})

```

## formula for Y

```{r}
formular_y <- paste(outcome,"~",paste(c(eps,mediator,tva,tf),collapse = " + "))
formular_y

test_that("test data formular for Y", {
  
  N_model_y <- glm(formular_y ,family = binomial, data = data_pro) |>
    suppressWarnings()
  
  aLong_model_y <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                       T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4, 
                     family = binomial, data = boot) |>
    suppressWarnings()
  
  expect_equal(min(N_model_y$fitted.values),min(aLong_model_y$fitted.values))
  expect_equal(max(N_model_y$fitted.values),max(aLong_model_y$fitted.values))
  expect_equal(mean(N_model_y$fitted.values),mean(aLong_model_y$fitted.values))
  expect_equal(sd(N_model_y$fitted.values),sd(aLong_model_y$fitted.values))
})
```




