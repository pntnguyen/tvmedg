---
title: "tvmedg package"
format:
  html:
    toc: true
    page-layout: full
    code-fold: show
    code-tools: true
editor: visual
message: false
warning: false
---

```{r}
library(tidyverse)
library(magrittr)
library(testthat)
library(splines)
```

# Import data

```{r}
dat0 <- readRDS("../Data/tvmed_dat100.RDS")
dat0 %>% as.data.frame() %>% as_tibble()
```

# Process data function

```{r}
process_data <- function(fix,expo,med,tvar,lag,outc,time,norev = NULL,LM = FALSE,data){
  
  ## detect which variables are non-reversible
  if(length(which(expo %in% norev)) != 0){
    norev_expo <- paste0("A",which(expo %in% norev))
  } else{
    norev_expo <- NULL
  }
  
  if(length(which(med %in% norev)) != 0){
    norev_med <- paste0("M",which(med %in% norev))
  } else {
    norev_med <- NULL
  }
  
  if(length(which(tvar %in% norev)) != 0){
    norev_tvar <- paste0("L",which(tvar %in% norev))
  } else {
    norev_tvar <- NULL
  }
  
  norev_var <- c(norev_expo,norev_med,norev_tvar)
  
  ## column names of time-fixed variables
  name_v <- paste0("v",1:length(fix))
  
  out <- data.frame(id = data$id) %>% 
    mutate(data[,fix]) %>% 
    magrittr::set_colnames(c("id",name_v))
  
  ## column names of exposure variables  
  name_e <- paste0("A",1:length(expo))
  
  ## column names of mediator variables  
  name_me <- paste0("M",1:length(med))
  
  ## column names of time-varying variables  
  name_tvar <- paste0("L",1:length(tvar))
  
  
  for (i in 1:lag){
    
    ## column name of lag effect on exposure variable
    co_ex <- paste0(name_e,"l",i)
    co_me <- paste0(name_me,"l",i)
    co_tvar <- paste0(name_tvar,"l",i)
    
    for (k in 1:length(name_e)){
      
      out[,name_e[k]] <- data[,expo[k]]
      name_ep <- {{co_ex}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_ep}} := lag(!!sym(name_e[k]),n=i,default = data[1,expo[k]])
        )
      
    } 
    
    for (k in 1:length(name_me)){
      
      out[,name_me[k]] <- data[,med[k]]
      name_med <- {{co_me}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_med}} := lag(!!sym(name_me[k]),n=i,default = data[1,med[k]])
        ) 
      
    }  
    
    for (k in 1:length(name_tvar)){
      
      out[,name_tvar[k]] <- data[,tvar[k]]
      name_tv <- {{co_tvar}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_tv}} := lag(!!sym(name_tvar[k]),n=i,default = data[1,tvar[k]])
        )
      
    }
    
    
  }
  
  ## outcome variable
  out$Y <- data[,outc]
  
  ## time variable
  out$j <- data[,time]
  
  kq <- list()
  kq$df <- out %>% data.frame() 
  kq$norev_var <- norev_var
  
  ## column name
  
  eps <- kq$df %>% select(starts_with("A")) %>% colnames()
  tf <- kq$df %>% select(starts_with("v")) %>% colnames()
  tva <- kq$df %>% select(starts_with("L")) %>% colnames()
  mediator <- kq$df %>% select(starts_with("M")) %>% colnames()
  outcome <- kq$df %>% select(starts_with("Y")) %>% colnames()
  timee <- kq$df %>% select(starts_with("j")) %>% colnames()
  
  
  ## formula for M(t)
  l_tm1 <- tva[!tva %in% name_tvar]
  m_tm1 <- mediator[!mediator %in% name_me]
  
  if (LM == FALSE){
    formula_mt <- list()
    
    for (i in 1:length(med)){
      formula_mt[i] <- paste(name_me[i],"~",paste(c(eps,m_tm1,l_tm1,tf),collapse = " + "))
    }
    
    kq$fm <- formula_mt
    
    ## formula for L(t)
    formular_lt <- list()
    
    for (i in 1:length(tvar)){
      formular_lt[i] <- paste(name_tvar[i],"~",paste(c(eps,mediator,l_tm1,tf),collapse = " + "))
    }
    
    kq$fl <- formular_lt
    
    ## formula for Y(t)
    formular_y <- paste(outcome,"~",paste(c(eps,mediator,tva,tf),collapse = " + "))
    kq$fy <- formular_y
    
  } else {
    formula_mt <- list()
    
    for (i in 1:length(med)){
      formula_mt[i] <- paste(name_me[i],"~",paste(c(eps,m_tm1,name_tvar,tf),collapse = " + "))
    }
    
    kq$fm <- formula_mt
    
    ## formula for L(t)
    formular_lt <- list()
    
    for (i in 1:length(tvar)){
      formular_lt[i] <- paste(name_tvar[i],"~",paste(c(eps,m_tm1,l_tm1,tf),collapse = " + "))
    }
    
    kq$fl <- formular_lt
    
    ## formula for Y(t)
    formular_y <- paste(outcome,"~",paste(c(eps,tva,mediator,tf),collapse = " + "))
    kq$fy <- formular_y
  }
  
  return(kq)
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = F,
  data = dat0
)  %>% str()
```

## Compare M before L, and L before M

```{r}
ml <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = F,
  data = dat0
)  

lm <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = T,
  data = dat0
)  

ml$fm
lm$fm

ml$fl
lm$fl
```

# cen_and_scale function

```{r}
cen_and_scale <- function(time){
  
  j_out <- list()
  
  jj <- time %>% 
    scale() 
  
  j_out[["jj"]] <- jj %>% as.numeric()
  j_out[["mean_j"]] <- attributes(jj)$`scaled:center`
  j_out[["sd_j"]] <- attributes(jj)$`scaled:scale`
  
  j_out
}
```

# resamp function

```{r}
resamp <- function(data,bootstr = FALSE){

  df <- data

  # set.seed(seed)
  # cat("Running SEED", seed, "\n")
  # cat("\n")
  # cat("Resampling Data", "\n")
  
  clusters <- names(table(df$id))
  index <- sample(1:length(clusters), length(clusters), replace = TRUE)
  bb <- table(clusters[index])
  boot <- NULL
  
  if(bootstr == F) {
    # not doing bootstrap
    boot <- df 
  } else {
    for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }
  }
  
  boot$jj <- cen_and_scale(boot$j)$jj
  
  boot
}
```

# fitg function

```{r}
fitg <- function(data,bootstr = FALSE,
                 mreg = "binomial",
                 lreg = c("binomial","gaussian","gaussian"),
                 yreg = "binomial",dof = 3){
  
  res_df <- resamp(data = data$df,bootstr = bootstr)
  
  fitR <- list()
  
  fitR$df <- res_df %>% as_tibble()

  #----- fit parametric models for
  #--- Mediator models
  
  if(length(mreg) != length(data$fm)){
    stop("the defined regression of M is not equal")
  }
  
  for (i in 1:length(data$fm)){
    fitM <- paste0(data$fm[[i]],"+","bs(jj,df=",dof,")")
    fitR$M[[i]] <- glm(fitM ,family = mreg[i], data = res_df) 
  }
  
  
  #--- Covariate models
  if(length(lreg) != length(data$fl)){
    stop("the defined regression of L is not equal")
  }
  
  for (i in 1:length(data$fl)){
    fitL <- paste0(data$fl[[i]],"+","bs(jj,df=",dof,")")
    fitR$L[[i]] <- glm(fitL ,family = lreg[i], data = res_df) 
  }
  
  #--- Outcome model: 
  fitY <- paste0(data$fy,"+","bs(jj,df=",dof,")")
  
  
  fitR$Y <-  glm(fitY ,family = yreg, data = res_df) 
  
  fitR$norev_var <- data$norev_var
  
  fitR
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = NULL,
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3)
```

# baseline_mc

```{r}
baseline_mc <- function(data = fitR2,montecarlo = 10000){
  
  boot <- data$df
  # Select baseline visit
  df0 <- boot[boot$j==1, ]
  
  df0$idn <- 1:nrow(df0)
  
  MC <- NULL
  
  samples <- sample(df0$idn, size = montecarlo, replace = T)
  bb <- table(samples)
  
  for(zzz in 1:max(bb)) {
    cc <- df0[df0$idn %in% names(bb[bb %in% c(zzz:max(bb))]), ]
    cc$bid <- paste0(cc$idn, zzz)
    MC <- rbind(MC, cc)
  }
  
  MC$idsim <- 1:montecarlo
  
  data$res_df <- MC %>% as_tibble()
  data
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  # norev = c("Mp","L1"),
  data = dat0
) %>% fitg(bootstr=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)
```


# g_form function

```{r}
pFunc <- function(mod, ndat) {
  as.numeric(predict(mod, newdata = ndat, type = "response") > runif(1))
}
  
rFunc <- function(mod, ndat) {
  pred_prob <- predict(mod, newdata = ndat, type = "response")
  return(rbinom(1, size = 1, prob = pred_prob))
}
```


```{r}
g_form <- function(data, ii = 2, length = 12, am = 1, ay = 0){
  
  norev_var <- data$norev_var
  
  dddd <- data$res_df %>% data.frame()
  
  lagg <- dddd %>% dplyr::select(contains("L1l")) %>% ncol() 
  
  d2 <- dddd[dddd$idsim==ii, ]
  
  id <- d2$idsim
  id_ori <- d2$id
  
  length <- length
  
  # Baseline covariates
  Vp <- d2 %>% select(starts_with("v"))
  
  Yp2 <- mm <- numeric()
  
  mm[1:lagg-1] <- j <- 1
  
  Yp2[1:lagg-1] <- 0
  
  timee <- cen_and_scale(data$df$j)
  
  # mediator
  Mp <- matrix(ncol = length(data$M)) %>% data.frame()
  names(Mp) <- paste0("M",1:length(data$M))
  Mp[1:lagg-1,] <- d2 %>% select(names(Mp)) 
  
  
  # time-varying covariates (contribute to mediator models)
  Lmp <- matrix(ncol = length(data$L)) %>% data.frame()
  names(Lmp) <- paste0("L",1:length(data$L))
  Lmp[1:lagg-1,] <- d2 %>% select(names(Lmp)) 
  # time-varying covariates (contribute to outcome models)
  Lp <- Lmp
  
  for (l in lagg:length) {
    
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  }
  
  colnames(Lmp) <- paste0("Lmp",1:length(data$L))
  colnames(Lp) <- paste0("Lp",1:length(data$L))
  
  # boot_num <- seed
  gdat2 <- data.frame(id, id_ori, mm, Ay = ay, Am = am, Mp, Yp2,
                     Lmp, Lp, Vp)
  gdat2$lastid <- as.numeric(!duplicated(gdat2$id, fromLast = T))
  return(gdat2)
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, am = 1, ay = 0)
```

## Output with non-reversible variable, and bootstrap

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, am = 1, ay = 0)
```

## Output with non-reversible variable, and bootstrap, L before M

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  LM = TRUE,
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 44, length = 12, am = 1, ay = 0)
```



# Test

## Set up

### df_prep

```{r}
df_prep <- function(data) {
  
  df <- data.frame(id = data$id)
  
  # Baseline characteristics
  df$v1 <- data$age
  df$v2 <- data$sex
  df$v3 <- data$ow
  df$v4 <- data$risk
  
  
  # Time-varying treatment
  df$A <- data$Ap
  df$Al1 <- data$A_lag1
  df$Al2 <- data$A_lag2
  
  
  # time-dependent covariate
  df$T1 <- data$L1
  df$T1l1 <- data$L1_lag1
  df$T1l2 <- data$L1_lag2
  
  df$T2 <- data$L2
  df$T2l1 <- data$L2_lag1
  df$T2l2 <- data$L2_lag2
  
  df$T3 <- data$L3
  df$T3l1 <- data$L3_lag1
  df$T3l2 <- data$L3_lag2

  # Mediator
  df$M1 <- data$Mp
  df$M1l1 <- data$M_lag1
  df$M1l2 <- data$M_lag2
  
  # outcomes
  df$Y <- data$Yp
  
  # Time
  df$j <- data$mm
  
  return(df)
}
```

### gform

```{r}
gform <- function(ii, pgdat, length, am, ay) {
  
  pFunc <- function(mod, ndat) {
    as.numeric(predict(mod, newdata = ndat, type = "response") > runif(1))
  }
  
  rFunc <- function(mod, ndat) {
    pred_prob <- predict(mod, newdata = ndat, type = "response")
    return(rbinom(1, size = 1, prob = pred_prob))
  }
  
  d <- pgdat
  d <- d[d$idsim==ii, ]
  
  id <- d$idsim
  id_ori <- d$id
  
  length <- length
  
  
  # cat("...", paste0(ii, "(", id_ori, ")"))
  
  
  
  # Baseline covariates
  Vp <- d[, c("v1", "v2", "v3", "v4")]
  
  T1p <- T2p <- T3p  <- M1p <- Yp <- mm <- numeric()
  T1mp <- T2mp <- T3mp <- numeric()
  
  mm[1] <- j <- 1
  
  
  M1p[1] <- 0
  Yp[1] <- 0
  
  # Time-varying covariates contribute to outcome model
  T1p[1] <- d$T1
  T2p[1] <- d$T2
  T3p[1] <- d$T3
  
  # Time-varying covariates contribute to mediator model
  T1mp[1] <- d$T1
  T2mp[1] <- d$T2
  T3mp[1] <- d$T3
  
  
  for (l in 2:length) {
    
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  }
  
  
  boot_num <- seed
  gdat <- data.frame(boot_num, id, id_ori, mm, Ay = ay, Am = am, M1p, Yp,
                     T1mp, T1p, T2mp, T2p, T3mp, T3p, Vp)
  gdat$lastid <- as.numeric(!duplicated(gdat$id, fromLast = T))
  return(gdat)
}
```


## Process data function

::: columns
::: {.column width="50%"}
```{r}
dat <- dat0 |> 
    group_by(id) |>
    mutate(
      A_lag1 = lag(Ap, n = 1, default = 0),
      A_lag2 = lag(Ap, n = 2, default = 0),
      M_lag1 = lag(Mp, n = 1, default = 0),
      M_lag2 = lag(Mp, n = 2, default = 0),
      L1_lag1 = lag(L1, n = 1, default = 0),
      L1_lag2 = lag(L1, n = 2, default = 0),
      L2_lag1 = lag(L2, n = 1, default = 100),
      L2_lag2 = lag(L2, n = 2, default = 100),
      L3_lag1 = lag(L3, n = 1, default = 80),
      L3_lag2 = lag(L3, n = 2, default = 80)
    ) |> ungroup() %>% df_prep()

dat %>% head()
```
:::

::: {.column width="50%"}
```{r}
data_pro <- process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) 

data_pro$df %>% head()
```
:::

:::

```{r}
test_that("process_data function", {
  ## id, v1 - v4
  expect_equal(dat[,c(1:5)],data_pro$df[,c(1:5)])
  
  ## exposure variables
  expect_equal(dat[,c("A")],data_pro$df[,c("A1")])
  expect_equal(dat[,c("Al1")],data_pro$df[,c("A1l1")])
  expect_equal(dat[,c("Al2")],data_pro$df[,c("A1l2")])
  
  ## time-dependent covariate
  expect_equal(dat[,c("T1")],data_pro$df[,c("L1")])
  expect_equal(dat[,c("T2")],data_pro$df[,c("L2")])
  expect_equal(dat[,c("T3")],data_pro$df[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(dat[,c("T1l1")],data_pro$df[,c("L1l1")])
  expect_equal(dat[,c("T2l1")],data_pro$df[,c("L2l1")])
  expect_equal(dat[,c("T3l1")],data_pro$df[,c("L3l1")])

  expect_equal(dat[,c("T1l2")],data_pro$df[,c("L1l2")])
  expect_equal(dat[,c("T2l2")],data_pro$df[,c("L2l2")])
  expect_equal(dat[,c("T3l2")],data_pro$df[,c("L3l2")])

  ## Mediator
  expect_equal(dat[,c("M1")],data_pro$df[,c("M1")])
  expect_equal(dat[,c("M1l1")],data_pro$df[,c("M1l1")])
  expect_equal(dat[,c("M1l2")],data_pro$df[,c("M1l2")])

  ## outcome and time
  expect_equal(dat[,c("Y","j")],data_pro$df[,c("Y","j")])
  
})
```

## fitg function

### seed = 0, no bootstrap

::: columns
::: {.column width="50%"}
```{r}

df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

boot <- df

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)

#----- fit parametric models for
#--- Mediator models

mM1 <- function(k){
  fitM1 <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitM1)
}

# PseudoR2(fitM1)
#--- Covariate models

mT1 <- function(k){
  fitT1 <- glm(T1 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitT1)
}

# PseudoR2(fitT1)

mT2 <- function(k){
  fitT2 <- lm(T2 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT2)
}

mT3 <- function(k){
  fitT3 <- lm(T3 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT3)
}

# Outcome model: E(Y|a, m, l, v)

mY <- function(k) {
  fitY <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
              family = binomial, data = boot)
  return(fitY)
}

# PseudoR2(fitY)

# Fit all models and save in a list
mR <- c(mM1, mY, mT1, mT2, mT3)
fitR <- lapply(1:5,function(x) mR[[x]](k))
```
:::

::: {.column width="50%"}
```{r}
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) 
```
:::

:::

```{r}
test_that("fitg function", {

  ## model M(t)
  expect_equal(min(fitR[[1]]$fitted.values),min(fitR2$M[[1]]$fitted.values))
  expect_equal(max(fitR[[1]]$fitted.values),max(fitR2$M[[1]]$fitted.values))
  expect_equal(mean(fitR[[1]]$fitted.values),mean(fitR2$M[[1]]$fitted.values))
  expect_equal(sd(fitR[[1]]$fitted.values),sd(fitR2$M[[1]]$fitted.values))

  ## model Y
  expect_equal(min(fitR[[2]]$fitted.values),min(fitR2$Y$fitted.values))
  expect_equal(max(fitR[[2]]$fitted.values),max(fitR2$Y$fitted.values))
  expect_equal(mean(fitR[[2]]$fitted.values),mean(fitR2$Y$fitted.values))
  expect_equal(sd(fitR[[2]]$fitted.values),sd(fitR2$Y$fitted.values))
  
  ## model L1
  expect_equal(min(fitR[[3]]$fitted.values),min(fitR2$L[[1]]$fitted.values))
  expect_equal(max(fitR[[3]]$fitted.values),max(fitR2$L[[1]]$fitted.values))
  expect_equal(mean(fitR[[3]]$fitted.values),mean(fitR2$L[[1]]$fitted.values))
  expect_equal(sd(fitR[[3]]$fitted.values),sd(fitR2$L[[1]]$fitted.values))
  
  ## model L2
  expect_equal(min(fitR[[4]]$fitted.values),min(fitR2$L[[2]]$fitted.values))
  expect_equal(max(fitR[[4]]$fitted.values),max(fitR2$L[[2]]$fitted.values))
  expect_equal(mean(fitR[[4]]$fitted.values),mean(fitR2$L[[2]]$fitted.values))
  expect_equal(sd(fitR[[4]]$fitted.values),sd(fitR2$L[[2]]$fitted.values))
  
  ## model L3
  expect_equal(min(fitR[[5]]$fitted.values),min(fitR2$L[[3]]$fitted.values))
  expect_equal(max(fitR[[5]]$fitted.values),max(fitR2$L[[3]]$fitted.values))
  expect_equal(mean(fitR[[5]]$fitted.values),mean(fitR2$L[[3]]$fitted.values))
  expect_equal(sd(fitR[[5]]$fitted.values),sd(fitR2$L[[3]]$fitted.values))
})
```

### seed != 0, bootstrap

::: columns
::: {.column width="50%"}
```{r}
## seed = 123
df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

set.seed(123)

clusters <- names(table(df$id))
index <- sample(1:length(clusters), length(clusters), replace = TRUE)
bb <- table(clusters[index])

boot <- NULL

for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)

#----- fit parametric models for
#--- Mediator models

mM1 <- function(k){
  fitM1 <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitM1)
}

# PseudoR2(fitM1)
#--- Covariate models

mT1 <- function(k){
  fitT1 <- glm(T1 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitT1)
}

# PseudoR2(fitT1)

mT2 <- function(k){
  fitT2 <- lm(T2 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT2)
}

mT3 <- function(k){
  fitT3 <- lm(T3 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT3)
}

# Outcome model: E(Y|a, m, l, v)

mY <- function(k) {
  fitY <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
              family = binomial, data = boot)
  return(fitY)
}

# PseudoR2(fitY)

# Fit all models and save in a list
mR <- c(mM1, mY, mT1, mT2, mT3)
fitR <- lapply(1:5,function(x) mR[[x]](k))
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) 
```
:::

:::

```{r}
test_that("fitg function", {

  ## model M(t)
  expect_equal(min(fitR[[1]]$fitted.values),min(fitR2$M[[1]]$fitted.values))
  expect_equal(max(fitR[[1]]$fitted.values),max(fitR2$M[[1]]$fitted.values))
  expect_equal(mean(fitR[[1]]$fitted.values),mean(fitR2$M[[1]]$fitted.values))
  expect_equal(sd(fitR[[1]]$fitted.values),sd(fitR2$M[[1]]$fitted.values))

  ## model Y
  expect_equal(min(fitR[[2]]$fitted.values),min(fitR2$Y$fitted.values))
  expect_equal(max(fitR[[2]]$fitted.values),max(fitR2$Y$fitted.values))
  expect_equal(mean(fitR[[2]]$fitted.values),mean(fitR2$Y$fitted.values))
  expect_equal(sd(fitR[[2]]$fitted.values),sd(fitR2$Y$fitted.values))
  
  ## model L1
  expect_equal(min(fitR[[3]]$fitted.values),min(fitR2$L[[1]]$fitted.values))
  expect_equal(max(fitR[[3]]$fitted.values),max(fitR2$L[[1]]$fitted.values))
  expect_equal(mean(fitR[[3]]$fitted.values),mean(fitR2$L[[1]]$fitted.values))
  expect_equal(sd(fitR[[3]]$fitted.values),sd(fitR2$L[[1]]$fitted.values))
  
  ## model L2
  expect_equal(min(fitR[[4]]$fitted.values),min(fitR2$L[[2]]$fitted.values))
  expect_equal(max(fitR[[4]]$fitted.values),max(fitR2$L[[2]]$fitted.values))
  expect_equal(mean(fitR[[4]]$fitted.values),mean(fitR2$L[[2]]$fitted.values))
  expect_equal(sd(fitR[[4]]$fitted.values),sd(fitR2$L[[2]]$fitted.values))
  
  ## model L3
  expect_equal(min(fitR[[5]]$fitted.values),min(fitR2$L[[3]]$fitted.values))
  expect_equal(max(fitR[[5]]$fitted.values),max(fitR2$L[[3]]$fitted.values))
  expect_equal(mean(fitR[[5]]$fitted.values),mean(fitR2$L[[3]]$fitted.values))
  expect_equal(sd(fitR[[5]]$fitted.values),sd(fitR2$L[[3]]$fitted.values))
})
```

## baseline_mc function

::: columns
::: {.column width="50%"}

```{r}
## seed = 123
df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

set.seed(123)

clusters <- names(table(df$id))
index <- sample(1:length(clusters), length(clusters), replace = TRUE)
bb <- table(clusters[index])

boot <- NULL

for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)


montecarlo = 10000
# Select baseline visit
  df0 <- boot[boot$j==1, ]
  
  df0$idn <- 1:nrow(df0)
  
  MC <- NULL
  
    samples <- sample(df0$idn, size = montecarlo, replace = T)
    bb <- table(samples)
    
    for(zzz in 1:max(bb)) {
      cc <- df0[df0$idn %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$idn, zzz)
      MC <- rbind(MC, cc)
    }
    
    MC$idsim <- 1:montecarlo
    
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)
```
:::

:::

```{r}
along_redf <- MC %>% as.data.frame()
test_redf <- fitR2$res_df %>% as.data.frame()

test_that("baseline_mc function", {

  # id, v1 - v4
  expect_equal(along_redf[,1],test_redf[,1])
  expect_equal(along_redf[,2],test_redf[,2])
  expect_equal(along_redf[,3],test_redf[,3])
  expect_equal(along_redf[,4],test_redf[,4])
  expect_equal(along_redf[,5],test_redf[,5])
  
  # exposure variables
  expect_equal(along_redf[,c("A")],test_redf[,c("A1")])
  expect_equal(along_redf[,c("Al1")],test_redf[,c("A1l1")])
  expect_equal(along_redf[,c("Al2")],test_redf[,c("A1l2")])

  ## time-dependent covariate
  expect_equal(along_redf[,c("T1")],test_redf[,c("L1")])
  expect_equal(along_redf[,c("T2")],test_redf[,c("L2")])
  expect_equal(along_redf[,c("T3")],test_redf[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(along_redf[,c("T1l1")],test_redf[,c("L1l1")])
  expect_equal(along_redf[,c("T2l1")],test_redf[,c("L2l1")])
  expect_equal(along_redf[,c("T3l1")],test_redf[,c("L3l1")])

  expect_equal(along_redf[,c("T1l2")],test_redf[,c("L1l2")])
  expect_equal(along_redf[,c("T2l2")],test_redf[,c("L2l2")])
  expect_equal(along_redf[,c("T3l2")],test_redf[,c("L3l2")])

  ## Mediator
  expect_equal(along_redf[,c("M1")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("M1l1")],test_redf[,c("M1l1")])
  expect_equal(along_redf[,c("M1l2")],test_redf[,c("M1l2")])

  ## outcome and time
  expect_equal(along_redf[,c("Y")],test_redf[,c("Y")])
  expect_equal(along_redf[,c("j")],test_redf[,c("j")])
})
```

## g_form function

### ay = 1, am = 1

::: columns
::: {.column width="50%"}

```{r}
seed = 123
set.seed(seed)
along_redf <- gform(ii = 1, pgdat = MC, length = 12, ay = 1, am = 1) %>% 
  as.data.frame()
```

:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 1, length = 12, ay = 1, am = 1) %>% data.frame()
```

:::

:::


```{r}
test_that("gform function", {

  # boot_num - Am
  expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
  expect_equal(along_redf[,c("v1","v2","v3","v4","lastid")],
               test_redf[,c("v1","v2","v3","v4","lastid")])

  expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
  expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
  expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
  expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
  expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
  expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
  expect_equal(along_redf[,c("Yp")], test_redf[,c("Yp2")])
})
```

### ay = 0, am = 0

::: columns
::: {.column width="50%"}

```{r}
seed = 123
set.seed(seed)
along_redf <- gform(ii = 2, pgdat = MC, length = 12, ay = 0, am = 0) %>% 
  as.data.frame()
```

:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, ay = 0, am = 0) %>% data.frame()
```

:::

:::


```{r}
test_that("gform function", {

  # boot_num - Am
  expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
  expect_equal(along_redf[,c("v1","v2","v3","v4","lastid")],
               test_redf[,c("v1","v2","v3","v4","lastid")])

  expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
  expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
  expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
  expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
  expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
  expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
  expect_equal(along_redf[,c("Yp")], test_redf[,c("Yp2")])
})
```

### ay = 0, am = 1

::: columns
::: {.column width="50%"}

```{r}
seed = 123
set.seed(123)
along_redf <- gform(ii = 2, pgdat = MC, length = 12, ay = 0, am = 1) %>% 
  as.data.frame()
along_redf
```

:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(bootstr=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)  %>% 
  g_form(ii = 2, length = 12, ay = 0, am = 1) %>% data.frame()
test_redf
```

:::

:::


```{r}
# test_that("gform function", {
# 
#   # boot_num - Am
#   expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
#   expect_equal(along_redf[,c("v1","v2","v3","v4","lastid","Yp")],
#                test_redf[,c("v1","v2","v3","v4","lastid","Yp")])
# 
#   expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
#   expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
#   expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
#   expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
#   expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
#   expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
#   expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
# })
```

# ay != am bị lỗi 

Như trường hợp tính khi am = 1, ay = 0 giữa 2 code k giống nhau nên em làm section để chạy lẻ các code xem lỗi ở đâu. Ở function của a Long thì chạy hết length nhưng Y vẫn = 0, còn function của em thì chạy tới 10 là Y = 1. Em nghĩ sự khác nhau giữa 2 outcome do cơ chế set.seed của R.

## 2 data bỏ vô g formula giống nhau

```{r}
along_redf <- MC %>% as.data.frame()
test_redf <- fitR2$res_df %>% as.data.frame()

test_that("baseline_mc function", {

  # id, v1 - v4
  expect_equal(along_redf[,1],test_redf[,1])
  expect_equal(along_redf[,2],test_redf[,2])
  expect_equal(along_redf[,3],test_redf[,3])
  expect_equal(along_redf[,4],test_redf[,4])
  expect_equal(along_redf[,5],test_redf[,5])
  
  # exposure variables
  expect_equal(along_redf[,c("A")],test_redf[,c("A1")])
  expect_equal(along_redf[,c("Al1")],test_redf[,c("A1l1")])
  expect_equal(along_redf[,c("Al2")],test_redf[,c("A1l2")])

  ## time-dependent covariate
  expect_equal(along_redf[,c("T1")],test_redf[,c("L1")])
  expect_equal(along_redf[,c("T2")],test_redf[,c("L2")])
  expect_equal(along_redf[,c("T3")],test_redf[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(along_redf[,c("T1l1")],test_redf[,c("L1l1")])
  expect_equal(along_redf[,c("T2l1")],test_redf[,c("L2l1")])
  expect_equal(along_redf[,c("T3l1")],test_redf[,c("L3l1")])

  expect_equal(along_redf[,c("T1l2")],test_redf[,c("L1l2")])
  expect_equal(along_redf[,c("T2l2")],test_redf[,c("L2l2")])
  expect_equal(along_redf[,c("T3l2")],test_redf[,c("L3l2")])

  ## Mediator
  expect_equal(along_redf[,c("M1")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("M1l1")],test_redf[,c("M1l1")])
  expect_equal(along_redf[,c("M1l2")],test_redf[,c("M1l2")])

  ## outcome and time
  expect_equal(along_redf[,c("Y")],test_redf[,c("Y")])
  expect_equal(along_redf[,c("j")],test_redf[,c("j")])
})
```

```{r}
ii = 2
length = 12
am = 1
ay = 0
```

::: columns
::: {.column width="50%"}

package code

```{r}
set.seed(123)
data = fitR2

## 
norev_var <- data$norev_var
  
  dddd <- data$res_df %>% data.frame()
  
  lagg <- dddd %>% dplyr::select(contains("L1l")) %>% ncol() 
  
  d2 <- dddd[dddd$idsim==ii, ]
  
  id <- d2$idsim
  id_ori <- d2$id
  
  length <- length
  
  # Baseline covariates
  Vp <- d2 %>% select(starts_with("v"))
  
  Yp2 <- mm <- numeric()
  
  mm[1:lagg-1] <- j <- 1
  
  Yp2[1:lagg-1] <- 0
  
  timee <- cen_and_scale(data$df$j)
  
  # mediator
  Mp <- matrix(ncol = length(data$M)) %>% data.frame()
  names(Mp) <- paste0("M",1:length(data$M))
  Mp[1:lagg-1,] <- d2 %>% select(names(Mp)) 
  
  
  # time-varying covariates (contribute to mediator models)
  Lmp <- matrix(ncol = length(data$L)) %>% data.frame()
  names(Lmp) <- paste0("L",1:length(data$L))
  Lmp[1:lagg-1,] <- d2 %>% select(names(Lmp)) 
  # time-varying covariates (contribute to outcome models)
  Lp <- Lmp
  
  for (l in lagg:length) {
  
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  }
  
  Yp2
```

:::

::: {.column width="50%"}

a Long code

```{r}
set.seed(123)
pgdat = MC

d <- pgdat
  d <- d[d$idsim==ii, ]
  
  id <- d$idsim
  id_ori <- d$id
  
  length <- length
  
  
  # cat("...", paste0(ii, "(", id_ori, ")"))
  
  
  
  # Baseline covariates
  Vp <- d[, c("v1", "v2", "v3", "v4")]
  
  T1p <- T2p <- T3p  <- M1p <- Yp <- mm <- numeric()
  T1mp <- T2mp <- T3mp <- numeric()
  
  mm[1] <- j <- 1
  
  
  M1p[1] <- 0
  Yp[1] <- 0
  
  # Time-varying covariates contribute to outcome model
  T1p[1] <- d$T1
  T2p[1] <- d$T2
  T3p[1] <- d$T3
  
  # Time-varying covariates contribute to mediator model
  T1mp[1] <- d$T1
  T2mp[1] <- d$T2
  T3mp[1] <- d$T3
  
  
  for (l in 2:length) {
    
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  }

Yp  
  
```


:::
:::

## tách data time = 5

theo như code của package thì ở time thứ 5 fit predict Y ở time thứ 6 = 1

nên em tách lúc time = 5 để xem data dùng để predict Y và sau đó l = 6 để predict

::: columns
::: {.column width="50%"}

package code

```{r}
set.seed(123)
data = fitR2

## 
norev_var <- data$norev_var
  
  dddd <- data$res_df %>% data.frame()
  
  lagg <- dddd %>% dplyr::select(contains("L1l")) %>% ncol() 
  
  d2 <- dddd[dddd$idsim==ii, ]
  
  id <- d2$idsim
  id_ori <- d2$id
  
  length <- length
  
  # Baseline covariates
  Vp <- d2 %>% select(starts_with("v"))
  
  Yp2 <- mm <- numeric()
  
  mm[1:lagg-1] <- j <- 1
  
  Yp2[1:lagg-1] <- 0
  
  timee <- cen_and_scale(data$df$j)
  
  # mediator
  Mp <- matrix(ncol = length(data$M)) %>% data.frame()
  names(Mp) <- paste0("M",1:length(data$M))
  Mp[1:lagg-1,] <- d2 %>% select(names(Mp)) 
  
  
  # time-varying covariates (contribute to mediator models)
  Lmp <- matrix(ncol = length(data$L)) %>% data.frame()
  names(Lmp) <- paste0("L",1:length(data$L))
  Lmp[1:lagg-1,] <- d2 %>% select(names(Lmp)) 
  # time-varying covariates (contribute to outcome models)
  Lp <- Lmp
 
  for (l in lagg:5) {
  
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  }
  
```

:::

::: {.column width="50%"}

a Long code

```{r}
set.seed(123)
pgdat = MC

d <- pgdat
  d <- d[d$idsim==ii, ]
  
  id <- d$idsim
  id_ori <- d$id
  
  length <- length
  
  
  # cat("...", paste0(ii, "(", id_ori, ")"))
  
  
  
  # Baseline covariates
  Vp <- d[, c("v1", "v2", "v3", "v4")]
  
  T1p <- T2p <- T3p  <- M1p <- Yp <- mm <- numeric()
  T1mp <- T2mp <- T3mp <- numeric()
  
  mm[1] <- j <- 1
  
  
  M1p[1] <- 0
  Yp[1] <- 0
  
  # Time-varying covariates contribute to outcome model
  T1p[1] <- d$T1
  T2p[1] <- d$T2
  T3p[1] <- d$T3
  
  # Time-varying covariates contribute to mediator model
  T1mp[1] <- d$T1
  T2mp[1] <- d$T2
  T3mp[1] <- d$T3
  
  
  for (l in 2:5) {
    
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  }


  
```


:::
:::

```{r}
## package
dfYp
## a Long code
dYp 
```

```{r}
### test
test_that("dataY function", {
  
  # boot_num - Am
  # expect_equal(dfYp[,c(2:6)],dYp[,c(1:5)])
  expect_equal(dfYp[,"v1"],dYp[,c("v1")])
  expect_equal(dfYp[,"v2"],dYp[,c("v2")])
  expect_equal(dfYp[,"v3"],dYp[,c("v3")])
  expect_equal(dfYp[,"v4"],dYp[,c("v4")])
  expect_equal(dfYp[,"A1"],dYp[,c("A")])
  expect_equal(dfYp[,"A1l1"],dYp[,c("Al1")])
  expect_equal(dfYp[,"A1l2"],dYp[,c("Al2")])
  expect_equal(dfYp[,"M1"],dYp[,c("M1")])
  expect_equal(dfYp[,"M1l1"],dYp[,c("M1l1")])
  expect_equal(dfYp[,"M1l2"],dYp[,c("M1l2")])
  expect_equal(dfYp[,"L1"],dYp[,c("T1")])
  expect_equal(dfYp[,"L1l1"],dYp[,c("T1l1")])
  expect_equal(dfYp[,"L1l2"],dYp[,c("T1l2")])
  expect_equal(dfYp[,"L2"],dYp[,c("T2")])
  expect_equal(dfYp[,"L2l1"],dYp[,c("T2l1")])
  expect_equal(dfYp[,"L2l2"],dYp[,c("T2l2")])
  expect_equal(dfYp[,"L3"],dYp[,c("T3")])
  expect_equal(dfYp[,"L3l1"],dYp[,c("T3l1")])
  expect_equal(dfYp[,"L3l2"],dYp[,c("T3l2")])
})
```

và model dùng để fit thì giống nhau

::: columns
::: {.column width="50%"}

```{r}
data$Y
```

:::

::: {.column width="50%"}

```{r}
fitR[[2]]
```

:::

:::
## predict time = 6

lúc này ở trên data đang có đến time = 5, nên em chỉ cần l = 6 để predict Y, thì lúc này predict lại ra là 0


::: columns
::: {.column width="50%"}

package code

```{r}

  
  # for (l in lagg:5) {
  l = 6
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  # }
    
 Yp2 
```

:::

::: {.column width="50%"}

```{r}
  
  # for (l in 2:5) {
    l = 6
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  # }

Yp
  
```


:::

:::


## predict đến length

::: columns
::: {.column width="50%"}

package code

```{r}

  
  for (l in 7:12) {
  
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  }
    
 Yp2
 
 colnames(Lmp) <- paste0("Lmp",1:length(data$L))
  colnames(Lp) <- paste0("Lp",1:length(data$L))
  
  # boot_num <- seed
  gdat2 <- data.frame(id, id_ori, mm, Ay = ay, Am = am, Mp, Yp2,
                     Lmp, Lp, Vp)
  gdat2$lastid <- as.numeric(!duplicated(gdat2$id, fromLast = T))
  
```

:::

::: {.column width="50%"}

a Long code

```{r}
  
  for (l in 7:12) {
    
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  }

Yp
# boot_num <- seed
 gdat <- data.frame(id, id_ori, mm, Ay = ay, Am = am, M1p, Yp,
                     T1mp, T1p, T2mp, T2p, T3mp, T3p, Vp)
  gdat$lastid <- as.numeric(!duplicated(gdat$id, fromLast = T)) 
  
   
```


:::

:::

## output

Theo output này thì các biến dùng để fit model Y ở time thứ 7 ở 2 code đều giống nhau. Nhưng predict lại ra khác nhau. Em nghĩ vì pFunc có runif() nên xác xuất ra khác nhau. Và thêm 1 phần là khi mình set am != ay thì các biến Lp của mình khác với các biến Lmp nên predict dễ gây sự khác nhau trong việc predict > runif(1) hơn so với khi am == ay thì Lp <- Lmp.

::: columns

::: {.column width="50%"}

```{r}
gdat2
```

:::

::: {.column width="50%"}

```{r}
gdat
```

:::

:::

# Function bự (tvmedg)

## tvmedg

bước đầu em setup ở ii = 2 để chạy so với g_boot của anh Long

```{r}
tvmedg <- function(data,
                   fix,expo,med,tvar,lag,outc,time,norev = NULL,LM = FALSE,
                   bootstr = FALSE, seed = 0,
                   mreg = "binomial",
                   lreg = c("binomial","gaussian","gaussian"),
                   yreg = "binomial",dof = 3,
                   montecarlo = 10000,length = 12,parallel=TRUE){
  
  set.seed(seed)
  
  fitR2 <- process_data(
    fix = fix,
    expo = expo,
    med = med,
    tvar = tvar,
    outc = outc,
    lag = lag,
    time = time,
    norev = norev,
    LM = LM,
    data = data
  )  %>% 
    fitg(bootstr=bootstr,
         mreg = mreg,
         lreg = lreg,
         yreg = yreg,dof = dof) %>% 
    baseline_mc(montecarlo = montecarlo)
  

    outdat11 <- g_form(ii = 2,data=fitR2, length = length, ay = 1, am = 1)
    outdat10 <- g_form(ii = 2,data=fitR2, length = length, ay = 1, am = 0)
    outdat00 <- g_form(ii = 2,data=fitR2, length = length, ay = 0, am = 0)
    
    rbind(outdat11, outdat10, outdat00)
  
}
```


## g_boot

```{r}
g_boot <- function(data, length = 12, montecarlo = 0, seed = 0,boostr = F) { 
  
  cat("g-formula for single mediator",'\n')
  
  df <- df_prep(data = data)
  
  set.seed(seed)
  cat("Running SEED", seed, "\n")
  cat("\n")
  cat("Resampling Data", "\n")
  
  # Resampling based on id and store in `boot` dataset
  clusters <- names(table(df$id))
  index <- sample(1:length(clusters), length(clusters), replace = TRUE)
  bb <- table(clusters[index])
  boot <- NULL
  
  if(boostr == F) {
    # not doing bootstrap
    boot <- df 
  } else {
    for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }
  }
  
  
  # Check boot data
  cat("Resampled data identical to original for seed =", seed, "?:", identical(boot, df),'\n')
  
  
  
  # Centering and scaling the time-scale variable
  boot$jj <- scale(boot$j)
  mean_j <- attributes(boot$jj)$`scaled:center`
  sd_j <- attributes(boot$jj)$`scaled:scale`
  boot$jj <- as.numeric(boot$jj)
  
  #----- fit parametric models for
  #--- Mediator models
  
  mM1 <- function(k){
    fitM1 <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                   v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
                 family = binomial, data = boot)
    return(fitM1)
  }
  
  # PseudoR2(fitM1)
  #--- Covariate models
  
  mT1 <- function(k){
    fitT1 <- glm(T1 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                   v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
                 family = binomial, data = boot)
    return(fitT1)
  }
  
  # PseudoR2(fitT1)
  
  mT2 <- function(k){
    fitT2 <- lm(T2 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
    return(fitT2)
  }
  
  mT3 <- function(k){
    fitT3 <- lm(T3 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
    return(fitT3)
  }
  
  # Outcome model: E(Y|a, m, l, v)
  
  mY <- function(k) {
    fitY <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                  T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
                family = binomial, data = boot)
    return(fitY)
  }
  
  # PseudoR2(fitY)
  
  # Fit all models and save in a list
  mR <- c(mM1, mY, mT1, mT2, mT3)
  fitR <- lapply(1:5,function(x) mR[[x]](k))
  
  
  
  # Select baseline visit
  df0 <- boot[boot$j==1, ]
  
  df0$idn <- 1:nrow(df0)
  
  MC <- NULL
  
    samples <- sample(df0$idn, size = montecarlo, replace = T)
    bb <- table(samples)
    
    for(zzz in 1:max(bb)) {
      cc <- df0[df0$idn %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$idn, zzz)
      MC <- rbind(MC, cc)
    }
    
    MC$idsim <- 1:montecarlo
  
  
  # pgf function for predicting follow-up
  #-----------------------------------------------------------------------------
  
  
  # pgf function
  gform <- function(ii, pgdat, length, am, ay) {
    
    pFunc <- function(mod, ndat) {
      as.numeric(predict(mod, newdata = ndat, type = "response") > runif(1))
    }
    
    rFunc <- function(mod, ndat) {
      pred_prob <- predict(mod, newdata = ndat, type = "response")
      return(rbinom(1, size = 1, prob = pred_prob))
    }
    
    d <- pgdat
    d <- d[d$idsim==ii, ]
    
    id <- d$idsim
    id_ori <- d$id
    
    length <- length
    
    
    # cat("...", paste0(ii, "(", id_ori, ")"))
    
    
    
    # Baseline covariates
    Vp <- d[, c("v1", "v2", "v3", "v4")]
    
    T1p <- T2p <- T3p  <- M1p <- Yp <- mm <- numeric()
    T1mp <- T2mp <- T3mp <- numeric()
    
    mm[1] <- j <- 1
    
    
    M1p[1] <- 0
    Yp[1] <- 0
    
    # Time-varying covariates contribute to outcome model
    T1p[1] <- d$T1
    T2p[1] <- d$T2
    T3p[1] <- d$T3
    
    # Time-varying covariates contribute to mediator model
    T1mp[1] <- d$T1
    T2mp[1] <- d$T2
    T3mp[1] <- d$T3
    
    
    for (l in 2:length) {
      
      if (Yp[l-1]==0) {
        
        if (l == 2) {
          T1l2 <- T1p[1]
          T2l2 <- T2p[1]
          T3l2 <- T3p[1]
          
          T1ml2 <- T1mp[1]
          T2ml2 <- T2mp[1]
          T3ml2 <- T3mp[1]
          M1l2 <- M1p[1]
          
        } else {
          
          T1l2 <- T1p[l-2]
          T2l2 <- T2p[l-2]
          T3l2 <- T3p[l-2]
          T1ml2 <- T1mp[l-2]
          T2ml2 <- T2mp[l-2]
          T3ml2 <- T3mp[l-2]
          M1l2 <- M1p[l-2]
          
        }
        
        T1l1 <- T1p[l-1]
        T2l1 <- T2p[l-1]
        T3l1 <- T3p[l-1]
        T1ml1 <- T1mp[l-1]
        T2ml1 <- T2mp[l-1]
        T3ml1 <- T3mp[l-1]
        
        M1l1 <- M1p[l-1]
        
        
        
        # Predict mediator
        dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                           T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                           jj = as.numeric((l-mean_j)/sd_j))
        
        if (M1p[l - 1] == 0) {
          # M1p[l] <- pFunc(fitR[[1]], dM1p)
          M1p[l] <- rFunc(fitR[[1]], dM1p)
        } else {
          M1p[l] <- 1
        }
        
        
        
        # Predict time-varying covariates (contribute to mediator models)
        # T1
        dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                            M1 = M1p[l], M1l1, M1l2, 
                            T1l1 = T1ml1, T1l2 = T1ml2, 
                            T2l1 = T2ml1, T2l2 = T2ml2, 
                            T3l1 = T3ml1,T3l2 = T3ml2,
                            jj = as.numeric((l-mean_j)/sd_j))
        T1mp[l] <- pFunc(fitR[[3]], dT1mp)
        
        # T2
        dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                            M1 = M1p[l], M1l1, M1l2, 
                            T1l1 = T1ml1, T1l2 = T1ml2, 
                            T2l1 = T2ml1, T2l2 = T2ml2, 
                            T3l1 = T3ml1, T3l2 = T3ml2,
                            jj = as.numeric((l-mean_j)/sd_j))
        T2mp[l] <- predict(fitR[[4]], dT2mp)
        
        # T3
        dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                            M1 = M1p[l], M1l1, M1l2,
                            T1l1 = T1ml1, T1l2 = T1ml2, 
                            T2l1 = T2ml1, T2l2 = T2ml2, 
                            T3l1 = T3ml1, T3l2 = T3ml2,
                            jj = as.numeric((l-mean_j)/sd_j))
        T3mp[l] <- predict(fitR[[5]], dT3mp)
        
        
        # Predict time-varying covariates (contribute to outcome models, if ay != am)
        # If ay = am ==> simply covariates take the same values between two models
        
        if (ay != am) {
          # T1
          dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                             M1 = M1p[l], M1l1, M1l2, 
                             T1l1, T1l2, 
                             T2l1, T2l2,  
                             T3l1, T3l2, 
                             jj = as.numeric((l-mean_j)/sd_j))
          T1p[l] <- pFunc(fitR[[3]], dT1p)
          
          # T2
          dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                             M1 = M1p[l], M1l1, M1l2, 
                             T1l1, T1l2, 
                             T2l1, T2l2,  
                             T3l1, T3l2, 
                             jj = as.numeric((l-mean_j)/sd_j))
          T2p[l] <- predict(fitR[[4]], dT2p)
          
          # T3
          dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                             M1 = M1p[l], M1l1, M1l2, 
                             T1l1, T1l2, 
                             T2l1, T2l2,  
                             T3l1, T3l2, 
                             jj = as.numeric((l-mean_j)/sd_j))
          T3p[l] <- predict(fitR[[5]], dT3p)
          
          
          
        } else {
          T1p[l] <- T1mp[l]
          T2p[l] <- T2mp[l]
          T3p[l] <- T3mp[l]
        }
        
        # Y
        dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                          T1 = T1p[l], T1l1, T1l2, 
                          T2 = T2p[l], T2l1, T2l2,
                          T3 = T3p[l], T3l1, T3l2, 
                          jj = as.numeric((l-mean_j)/sd_j))
        Yp[l] <- pFunc(fitR[[2]], dYp)
        
      } else {
        break
      }
      
      mm[l] <- l
      
    }
    
    
    # boot_num <- seed
    gdat <- data.frame(id, id_ori, mm, Ay = ay, Am = am, M1p, Yp,
                       T1mp, T1p, T2mp, T2p, T3mp, T3p, Vp)
    gdat$lastid <- as.numeric(!duplicated(gdat$id, fromLast = T))
    return(gdat)
  }
  
    outdat11 <- gform(ii = 2, pgdat = MC, length = length, ay = 1, am = 1)
    outdat10 <- gform(ii = 2, pgdat = MC, length = length, ay = 1, am = 0)
    outdat00 <- gform(ii = 2, pgdat = MC, length = length, ay = 0, am = 0)
    
    rbind(outdat11, outdat10, outdat00)
  
}
```

## Run

::: columns
::: {.column width="50%"}

```{r}
aaa2 <- tvmedg(data = dat0,
       fix = c("age","sex","ow","risk"),
       expo = c("Ap"),
       med = c("Mp"),
       tvar = c("L1","L2","L3"),
       outc = c("Yp"),
       lag = 2,
       norev = c("Mp"),
       time = c("mm"),
       LM = F,
       bootstr = T,
       seed = 444,
       mreg = "binomial",
       lreg = c("binomial","gaussian","gaussian"),
       yreg = "binomial",dof = 3,
       montecarlo = 10000,length = 12)
```

:::
::: {.column width="50%"}

```{r}
dat <- readRDS("../Data/tvmed_dat100.RDS")

dat <- dat |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup()

aaa <-  g_boot(data = dat, length = 12, 
               montecarlo = 10000, seed = 444,
               boostr = T) 
```

:::
:::

## Output

Em có extract những output cần so giữa 2 function với nhau ở dưới

::: columns
::: {.column width="50%"}

tvmedg

```{r}
aaa2
```

:::
::: {.column width="50%"}

g_boot

```{r}
aaa
```


:::

:::


```{r}
# test_that("process_data function", {
#   
#   expect_equal(aaa[,2:6],aaa2[,1:5])
#   expect_equal(aaa[,"T1mp"],aaa2[,"Lmp1"])
#   expect_equal(aaa[,"T2mp"],aaa2[,"Lmp2"])
#   expect_equal(aaa[,"T3mp"],aaa2[,"Lmp3"])
#   expect_equal(aaa[,"T1p"],aaa2[,"Lp1"])
#   expect_equal(aaa[,"T2p"],aaa2[,"Lp2"])
#   expect_equal(aaa[,"T3p"],aaa2[,"Lp3"])
#   expect_equal(aaa[,c("v1","v2","v3","v4","lastid")],aaa2[,c("v1","v2","v3","v4","lastid")])
# })
```

## Extract variables

Ở time 11, am = ap = 1 thì code a Long tính ra Tmp1 = Tp1 = 1 => dẫn đến các variables Lmp2, Lmp3 khác nhau ở time 12 và cũng có xác suất T1mp có thể ra 1. Ở time 2 am != ap, Tp1 = 1. Em nghĩ vấn đề khác nhau này thì mình chạy nhiều lấy mean thì k sao, nhưng mình k có test coverage cho package mình được.

```{r}
cp <- cbind(aaa2[,c("Ay","Am","mm","M1","Lmp1","Lmp2","Lmp3","Lp1","Lp2","Lp3","Yp2")],aaa[,c("M1p","T1mp","T2mp","T3mp","T1p","T2p","T3p","Yp")])
cp[,c("Ay","Am","mm","M1","M1p","Lmp1","T1mp","Lmp2","T2mp","Lmp3","T3mp","Lp1","T1p","Lp2","T2p","Lp3","T3p","Yp2","Yp")]
```


# Final tvmedg function

```{r}
tvmedg <- function(data,
                   fix,expo,med,tvar,lag,outc,time,norev = NULL,LM = FALSE,
                   bootstr = FALSE, seed = 0,
                   mreg = "binomial",
                   lreg = c("binomial","gaussian","gaussian"),
                   yreg = "binomial",dof = 3,
                   montecarlo = 10000,length = 12,parallel=TRUE){
  
  set.seed(seed)
  
  fitR2 <- process_data(
    fix = fix,
    expo = expo,
    med = med,
    tvar = tvar,
    outc = outc,
    lag = lag,
    time = time,
    norev = norev,
    LM = LM,
    data = data
  )  %>% 
    fitg(bootstr=bootstr,
         mreg = mreg,
         lreg = lreg,
         yreg = yreg,dof = dof) %>% 
    baseline_mc(montecarlo = montecarlo)
  
    start_time <- Sys.time()
    
    if (parallel == TRUE){
      
      gform_wrapper2 <- function(iii, data, length) {
        outdat11 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 1)
        outdat10 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 0)
        outdat00 <- g_form(ii = iii,data=data, length = length, ay = 0, am = 0)
        bind_rows(outdat11, outdat10, outdat00)
      }

      resultDatM <- future_map_dfr(1:montecarlo,  
                                   ~ gform_wrapper2(ii = .x, data = fitR2, length = length))
    } else {
      resultDatM <- data.frame()
      for (iii in 1:montecarlo){
        outdat11 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 1)
        outdat10 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 0)
        outdat00 <- g_form(ii = iii,data=data, length = length, ay = 0, am = 0)
        resultDatM2 <- rbind(outdat11, outdat10, outdat00)
        resultDatM <- rbind(resultDatM,resultDatM2)
      }
    }
    
    
  end_time <- Sys.time()
  elapsed_time <- end_time - start_time
  
  print(elapsed_time)
  return(resultDatM)
  
}
```

Em chạy trước montecarlo = 100 tại chạy 10000 nó lâu quá :)))

```{r}
library(furrr)
library(doParallel)

cl <- makeCluster(8)
registerDoParallel(cl)

datMC <- tvmedg(data = dat0,
       fix = c("age","sex","ow","risk"),
       expo = c("Ap"),
       med = c("Mp"),
       tvar = c("L1","L2","L3"),
       outc = c("Yp"),
       lag = 2,
       norev = c("Mp"),
       time = c("mm"),
       LM = F,
       bootstr = T,
       seed = 123,
       mreg = "binomial",
       lreg = c("binomial","gaussian","gaussian"),
       yreg = "binomial",dof = 3,
       montecarlo = 100,length = 12,
       parallel=TRUE)
```

```{r}
ExtResult <- function(data) {
  Q11 <- data |> filter(lastid == 1 & Ay ==1 & Am ==1)
  Q10 <- data |> filter(lastid == 1 & Ay ==1 & Am ==0)
  Q00 <- data |> filter(lastid == 1 & Ay ==0 & Am ==0)
  
  cat("Q(1,1):", round(mean(Q11$Yp), 3),'\n')
  cat("Q(1,0):", round(mean(Q10$Yp), 3),'\n')
  cat("Q(0,0):", round(mean(Q00$Yp), 3),'\n')
  
  cat("Indirect:", round(mean(Q11$Yp) - mean(Q10$Yp), 3),'\n')
  cat("Direct:", round(mean(Q10$Yp) - mean(Q00$Yp), 3),'\n')
  cat("Total:", round(mean(Q11$Yp) - mean(Q00$Yp), 3),'\n')
  cat("Proportional explain:", 
      round((mean(Q11$Yp) - mean(Q10$Yp))/(mean(Q11$Yp) - mean(Q00$Yp)), 3),'\n')
}
```

```{r}
ExtResult(datMC)
```

# Note

Note những vấn đề e còn thắc mắc:

- Em chưa hiểu intergration của montecarlo sẽ làm như thế nào.

- Việc 2 function cho ra kết quả khác nhau khi ay != am. Em vẫn đang lăn tăn là do em code có sai k. Em đã check việc dùng data và formula để fit và em vẫn nghĩ do tính random của rFunc() và Pfunc() nên ra kết quả khác nhau.

- Em chưa làm function để tính 95% CI.

