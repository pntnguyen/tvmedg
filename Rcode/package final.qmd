---
title: "tvmedg package"
format:
  html:
    toc: true
    page-layout: full
    code-fold: show
    code-tools: true
editor: visual
message: false
warning: false
---

```{r}
library(tidyverse)
library(magrittr)
library(testthat)
# library(splines)
```

# Import data

```{r}
dat0 <- readRDS("../Data/tvmed_dat100_12mo.RDS")
dat0 %>% as.data.frame() %>% as_tibble()
```

# Process data function

```{r}
process_data <- function(fix,expo,med,tvar,lag,outc,time,norev = NULL,LM = FALSE,data){
  
  ## detect which variables are non-reversible
  if(length(which(expo %in% norev)) != 0){
    norev_expo <- paste0("A",which(expo %in% norev))
  } else{
    norev_expo <- NULL
  }
  
  if(length(which(med %in% norev)) != 0){
    norev_med <- paste0("M",which(med %in% norev))
  } else {
    norev_med <- NULL
  }
  
  if(length(which(tvar %in% norev)) != 0){
    norev_tvar <- paste0("L",which(tvar %in% norev))
  } else {
    norev_tvar <- NULL
  }
  
  norev_var <- c(norev_expo,norev_med,norev_tvar)
  
  ## column names of time-fixed variables
  name_v <- paste0("v",1:length(fix))
  
  out <- data.frame(id = data$id) %>% 
    mutate(data[,fix]) %>% 
    magrittr::set_colnames(c("id",name_v))
  
  ## column names of exposure variables  
  name_e <- paste0("A",1:length(expo))
  
  ## column names of mediator variables  
  name_me <- paste0("M",1:length(med))
  
  ## column names of time-varying variables  
  name_tvar <- paste0("L",1:length(tvar))
  
  
  for (i in 1:lag){
    
    ## column name of lag effect on exposure variable
    co_ex <- paste0(name_e,"l",i)
    co_me <- paste0(name_me,"l",i)
    co_tvar <- paste0(name_tvar,"l",i)
    
    for (k in 1:length(name_e)){
      
      out[,name_e[k]] <- data[,expo[k]]
      name_ep <- {{co_ex}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_ep}} := lag(!!sym(name_e[k]),n=i,default = data[1,expo[k]])
        )
      
    } 
    
    for (k in 1:length(name_me)){
      
      out[,name_me[k]] <- data[,med[k]]
      name_med <- {{co_me}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_med}} := lag(!!sym(name_me[k]),n=i,default = data[1,med[k]])
        ) 
      
    }  
    
    for (k in 1:length(name_tvar)){
      
      out[,name_tvar[k]] <- data[,tvar[k]]
      name_tv <- {{co_tvar}}[k]
      out <- out %>% 
        group_by(id) %>% 
        mutate(
          {{name_tv}} := lag(!!sym(name_tvar[k]),n=i,default = data[1,tvar[k]])
        )
      
    }
    
    
  }
  
  ## outcome variable
  out$Y <- data[,outc]
  
  ## time variable
  out$j <- data[,time]
  
  kq <- list()
  kq$df <- out %>% data.frame() 
  kq$norev_var <- norev_var
  
  ## column name
  
  eps <- kq$df %>% select(starts_with("A")) %>% colnames()
  tf <- kq$df %>% select(starts_with("v")) %>% colnames()
  tva <- kq$df %>% select(starts_with("L")) %>% colnames()
  mediator <- kq$df %>% select(starts_with("M")) %>% colnames()
  outcome <- kq$df %>% select(starts_with("Y")) %>% colnames()
  timee <- kq$df %>% select(starts_with("j")) %>% colnames()
  
  
  ## formula for M(t)
  l_tm1 <- tva[!tva %in% name_tvar]
  m_tm1 <- mediator[!mediator %in% name_me]
  
  if (LM == FALSE){
    formula_mt <- list()
    
    for (i in 1:length(med)){
      formula_mt[i] <- paste(name_me[i],"~",paste(c(eps,m_tm1,l_tm1,tf),collapse = " + "))
    }
    
    kq$fm <- formula_mt
    
    ## formula for L(t)
    formular_lt <- list()
    
    for (i in 1:length(tvar)){
      formular_lt[i] <- paste(name_tvar[i],"~",paste(c(eps,mediator,l_tm1,tf),collapse = " + "))
    }
    
    kq$fl <- formular_lt
    
    ## formula for Y(t)
    formular_y <- paste(outcome,"~",paste(c(eps,mediator,tva,tf),collapse = " + "))
    kq$fy <- formular_y
    
  } else {
    formula_mt <- list()
    
    for (i in 1:length(med)){
      formula_mt[i] <- paste(name_me[i],"~",paste(c(eps,m_tm1,name_tvar,l_tm1,tf),collapse = " + "))
    }
    
    kq$fm <- formula_mt
    
    ## formula for L(t)
    formular_lt <- list()
    
    for (i in 1:length(tvar)){
      formular_lt[i] <- paste(name_tvar[i],"~",paste(c(eps,m_tm1,l_tm1,tf),collapse = " + "))
    }
    
    kq$fl <- formular_lt
    
    ## formula for Y(t)
    formular_y <- paste(outcome,"~",paste(c(eps,tva,mediator,tf),collapse = " + "))
    kq$fy <- formular_y
  }
  
  return(kq)
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = F,
  data = dat0
)  %>% str()
```

## Compare M before L, and L before M

```{r}
ml <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = F,
  data = dat0
)  

lm <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = c("Mp"),
  LM = T,
  data = dat0
)  

ml$fm
lm$fm

ml$fl
lm$fl
```

# cen_and_scale function

```{r}
cen_and_scale <- function(time){
  
  j_out <- list()
  
  jj <- time %>% 
    scale() 
  
  j_out[["jj"]] <- jj %>% as.numeric()
  j_out[["mean_j"]] <- attributes(jj)$`scaled:center`
  j_out[["sd_j"]] <- attributes(jj)$`scaled:scale`
  
  j_out
}
```

# resamp function

```{r}
resamp <- function(data,boot = FALSE){

  df <- data

  # set.seed(seed)
  # cat("Running SEED", seed, "\n")
  # cat("\n")
  # cat("Resampling Data", "\n")
  
  clusters <- names(table(df$id))
  index <- sample(1:length(clusters), length(clusters), replace = TRUE)
  bb <- table(clusters[index])
  boot_df <- NULL
  
  if(boot == F) {
    # not doing bootstrap
    boot_df <- df 
  } else {
    for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot_df <- rbind(boot_df, cc)
    }
  }
  
  boot_df$jj <- cen_and_scale(boot_df$j)$jj
  
  boot_df
}
```

# fitg function

```{r}
fitg <- function(data,boot = FALSE,
                 mreg = "binomial",
                 lreg = c("binomial","gaussian","gaussian"),
                 yreg = "binomial",dof = 3){
  
  res_df <- resamp(data = data$df,boot = boot)
  
  fitR <- list()
  
  fitR$df <- res_df %>% as_tibble()

  #----- fit parametric models for
  #--- Mediator models
  
  if(length(mreg) != length(data$fm)){
    stop("the defined regression of M is not equal")
  }
  
  for (i in 1:length(data$fm)){
    fitM <- paste0(data$fm[[i]],"+","splines::bs(jj,df=",dof,")")
    fitR$M[[i]] <- glm(fitM ,family = mreg[i], data = res_df) 
  }
  
  
  #--- Covariate models
  if(length(lreg) != length(data$fl)){
    stop("the defined regression of L is not equal")
  }
  
  for (i in 1:length(data$fl)){
    fitL <- paste0(data$fl[[i]],"+","splines::bs(jj,df=",dof,")")
    fitR$L[[i]] <- glm(fitL ,family = lreg[i], data = res_df) 
  }
  
  #--- Outcome model: 
  fitY <- paste0(data$fy,"+","splines::bs(jj,df=",dof,")")
  
  
  fitR$Y <-  glm(fitY ,family = yreg, data = res_df) 
  
  fitR$norev_var <- data$norev_var
  
  fitR
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  norev = NULL,
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3)
```

# baseline_mc

```{r}
baseline_mc <- function(data = fitR2,montecarlo = 10000){
  
  boot <- data$df
  # Select baseline visit
  df0 <- boot[boot$j==1, ]
  
  df0$idn <- 1:nrow(df0)
  
  MC <- NULL
  
  samples <- sample(df0$idn, size = montecarlo, replace = T)
  bb <- table(samples)
  
  for(zzz in 1:max(bb)) {
    cc <- df0[df0$idn %in% names(bb[bb %in% c(zzz:max(bb))]), ]
    cc$bid <- paste0(cc$idn, zzz)
    MC <- rbind(MC, cc)
  }
  
  MC$idsim <- 1:montecarlo
  
  data$res_df <- MC %>% as_tibble()
  data
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  # norev = c("Mp","L1"),
  data = dat0
) %>% fitg(boot=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)
```

# g_form function

```{r}
pFunc <- function(mod, ndat) {
  as.numeric(predict(mod, newdata = ndat, type = "response") > runif(1))
}
  
rFunc <- function(mod, ndat) {
  pred_prob <- predict(mod, newdata = ndat, type = "response")
  return(rbinom(1, size = 1, prob = pred_prob))
}
```

```{r}
g_form <- function(data, ii = 2, length = 12, am = 1, ay = 0){
  
  norev_var <- data$norev_var
  
  dddd <- data$res_df %>% data.frame()
  
  lagg <- dddd %>% dplyr::select(contains("L1l")) %>% ncol() 
  
  d2 <- dddd[dddd$idsim==ii, ]
  
  id <- d2$idsim
  id_ori <- d2$id
  
  length <- length
  
  # Baseline covariates
  Vp <- d2 %>% select(starts_with("v"))
  
  Yp2 <- mm <- numeric()
  
  mm[1:lagg-1] <- j <- 1
  
  Yp2[1:lagg-1] <- 0
  
  timee <- cen_and_scale(data$df$j)
  
  # mediator
  Mp <- matrix(ncol = length(data$M)) %>% data.frame()
  names(Mp) <- paste0("M",1:length(data$M))
  Mp[1:lagg-1,] <- d2 %>% select(names(Mp)) 
  
  
  # time-varying covariates (contribute to mediator models)
  Lmp <- matrix(ncol = length(data$L)) %>% data.frame()
  names(Lmp) <- paste0("L",1:length(data$L))
  Lmp[1:lagg-1,] <- d2 %>% select(names(Lmp)) 
  # time-varying covariates (contribute to outcome models)
  Lp <- Lmp
  
  for (l in lagg:length) {
    
    if (Yp2[l-1]==1) {
      break
    } else{
      
      # Predict mediator
      var_fm <- attr(data$M[[1]]$terms, "term.labels")
      var_fm <- var_fm[-length(var_fm)] 
      
      dfMp <- d2 %>% select(matches(var_fm)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      
      dfMp[startsWith(colnames(dfMp), "A")] <- am
      
      
      if (l > lagg){
        
        for (zz in 1:(lagg)){
          term <- paste0("l",zz)
          # L lag
          dfMp[startsWith(colnames(dfMp), "L") & endsWith(colnames(dfMp), term)] <- Lmp[l-zz,]
          # M lag
          dfMp[startsWith(colnames(dfMp), "M") & endsWith(colnames(dfMp), term)] <- Mp[l-zz,]
        }
        
      }
      
      
      for (x in 1:length(data$M)){
        
        M_reg <- data$M[[x]]$family$family
        
        if (names(Mp[x]) %in% norev_var){
          
          if (M_reg == "binomial" & Mp[l-1,x] == 1) {
            Mp[l,x] <- 1
          } else {
            Mp[l,x] <- case_when(
              M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
              M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
            )
          }
          
        } else {
          
          Mp[l,x] <- case_when(
            M_reg  == "binomial" ~ rFunc(data$M[[x]], dfMp),
            M_reg  == "gaussian" ~ predict(data$M[[x]], dfMp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to mediator models)
      # L
      var_fl <- attr(data$L[[1]]$terms, "term.labels")
      var_fl <- var_fl[-length(var_fl)] 
      dfLmp <- d2 %>% select(matches(var_fl)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfLmp[startsWith(colnames(dfLmp), "A")] <- am
      dfLmp[colnames(dfLmp) == colnames(Mp)] <- Mp[l,]
      
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfLmp[startsWith(colnames(dfLmp), "L") & endsWith(colnames(dfLmp), term)] <- Lmp[l-zz,]
          # M lag
          dfLmp[startsWith(colnames(dfLmp), "M") & endsWith(colnames(dfLmp), term)] <- Mp[l-zz,]
        }
        
      }
      
      for (x in 1:length(data$L)){
        
        L_reg <- data$L[[x]]$family$family
        
        if (names(Lmp[x]) %in% norev_var){
          if (L_reg == "binomial" & Lmp[l-1,x] == 1){
            
            Lmp[l,x] <- 1
            
          } else {
            
            Lmp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
            )
            
          }
          
        } else{
          
          Lmp[l,x] <- case_when(
            L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLmp),
            L_reg  == "gaussian" ~ predict(data$L[[x]], dfLmp)
          )
          
        }
        
      }
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      if (ay != am) {
        dfLp <- d2 %>% select(matches(var_fl)) %>% 
          mutate(jj = (l-timee$mean_j)/timee$sd_j)
        dfLp[startsWith(colnames(dfLp), "A")] <- ay
        dfLp[colnames(dfLp) == colnames(Mp)] <- Mp[l,]
        
        if (l > lagg){
          
          for (zz in 1:lagg){
            term <- paste0("l",zz)
            # L lag
            dfLp[startsWith(colnames(dfLp), "L") & endsWith(colnames(dfLp), term)] <- Lp[l-zz,]
            # M lag
            dfLp[startsWith(colnames(dfLp), "M") & endsWith(colnames(dfLp), term)] <- Mp[l-zz,]
          }
          
        }
        
        for (x in 1:length(data$L)){
          
          L_reg <- data$L[[x]]$family$family
          
          if (names(Lp[x]) %in% norev_var){
            if (L_reg == "binomial" & Lp[l-1,x] == 1){
              
              Lp[l,x] <- 1
              
            } else {
              
              Lp[l,x] <- case_when(
                L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
                L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
              )
              
            }
            
          } else {
            
            Lp[l,x] <- case_when(
              L_reg  == "binomial" ~ pFunc(data$L[[x]], dfLp),
              L_reg  == "gaussian" ~ predict(data$L[[x]], dfLp)
            )
            
          }
          
        }
        
      } else{
        Lp <- Lmp
      }
      
      # Y
      var_y <- attr(data$Y$terms, "term.labels")
      var_y <- var_y[-length(var_y)] 
      dfYp <- d2 %>% select(matches(var_y)) %>% 
        mutate(jj = (l-timee$mean_j)/timee$sd_j)
      dfYp[startsWith(colnames(dfYp), "A")] <- ay
      dfYp[colnames(dfYp) %in% colnames(Mp)] <- Mp[l,]
      dfYp[colnames(dfYp) %in% colnames(Lp)] <- Lp[l,] 
      
      if (l > lagg){
        
        for (zz in 1:lagg){
          term <- paste0("l",zz)
          # L lag
          dfYp[startsWith(colnames(dfYp), "L") & endsWith(colnames(dfYp), term)] <- Lp[l-zz,]
          # M lag
          dfYp[startsWith(colnames(dfYp), "M") & endsWith(colnames(dfYp), term)] <- Mp[l-zz,]
        }
        
      }
      
      Yp2[l] <- pFunc(data$Y, dfYp)
      
    }
    
    mm[l] <- l
  }
  
  colnames(Lmp) <- paste0("Lmp",1:length(data$L))
  colnames(Lp) <- paste0("Lp",1:length(data$L))
  
  # boot_num <- seed
  gdat2 <- data.frame(id, id_ori, mm, Ay = ay, Am = am, Mp, Yp2,
                     Lmp, Lp, Vp)
  gdat2$lastid <- as.numeric(!duplicated(gdat2$id, fromLast = T))
  return(gdat2)
}
```

## Output

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(boot=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, am = 1, ay = 0)
```

## Output with non-reversible variable, and bootstrap

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, am = 1, ay = 0)
```

## Output with non-reversible variable, and bootstrap, L before M

```{r}
process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  LM = TRUE,
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 44, length = 12, am = 1, ay = 0)
```

# Test

## Set up

### df_prep

```{r}
df_prep <- function(data) {
  
  df <- data.frame(id = data$id)
  
  # Baseline characteristics
  df$v1 <- data$age
  df$v2 <- data$sex
  df$v3 <- data$ow
  df$v4 <- data$risk
  
  
  # Time-varying treatment
  df$A <- data$Ap
  df$Al1 <- data$A_lag1
  df$Al2 <- data$A_lag2
  
  
  # time-dependent covariate
  df$T1 <- data$L1
  df$T1l1 <- data$L1_lag1
  df$T1l2 <- data$L1_lag2
  
  df$T2 <- data$L2
  df$T2l1 <- data$L2_lag1
  df$T2l2 <- data$L2_lag2
  
  df$T3 <- data$L3
  df$T3l1 <- data$L3_lag1
  df$T3l2 <- data$L3_lag2

  # Mediator
  df$M1 <- data$Mp
  df$M1l1 <- data$M_lag1
  df$M1l2 <- data$M_lag2
  
  # outcomes
  df$Y <- data$Yp
  
  # Time
  df$j <- data$mm
  
  return(df)
}
```

### gform

```{r}
gform <- function(ii, pgdat, length, am, ay) {
  
  pFunc <- function(mod, ndat) {
    as.numeric(predict(mod, newdata = ndat, type = "response") > runif(1))
  }
  
  rFunc <- function(mod, ndat) {
    pred_prob <- predict(mod, newdata = ndat, type = "response")
    return(rbinom(1, size = 1, prob = pred_prob))
  }
  
  d <- pgdat
  d <- d[d$idsim==ii, ]
  
  id <- d$idsim
  id_ori <- d$id
  
  length <- length
  
  
  # cat("...", paste0(ii, "(", id_ori, ")"))
  
  
  
  # Baseline covariates
  Vp <- d[, c("v1", "v2", "v3", "v4")]
  
  T1p <- T2p <- T3p  <- M1p <- Yp <- mm <- numeric()
  T1mp <- T2mp <- T3mp <- numeric()
  
  mm[1] <- j <- 1
  
  
  M1p[1] <- 0
  Yp[1] <- 0
  
  # Time-varying covariates contribute to outcome model
  T1p[1] <- d$T1
  T2p[1] <- d$T2
  T3p[1] <- d$T3
  
  # Time-varying covariates contribute to mediator model
  T1mp[1] <- d$T1
  T2mp[1] <- d$T2
  T3mp[1] <- d$T3
  
  
  for (l in 2:length) {
    
    if (Yp[l-1]==0) {
      
      if (l == 2) {
        T1l2 <- T1p[1]
        T2l2 <- T2p[1]
        T3l2 <- T3p[1]
        
        T1ml2 <- T1mp[1]
        T2ml2 <- T2mp[1]
        T3ml2 <- T3mp[1]
        M1l2 <- M1p[1]
        
      } else {
        
        T1l2 <- T1p[l-2]
        T2l2 <- T2p[l-2]
        T3l2 <- T3p[l-2]
        T1ml2 <- T1mp[l-2]
        T2ml2 <- T2mp[l-2]
        T3ml2 <- T3mp[l-2]
        M1l2 <- M1p[l-2]
        
      }
      
      T1l1 <- T1p[l-1]
      T2l1 <- T2p[l-1]
      T3l1 <- T3p[l-1]
      T1ml1 <- T1mp[l-1]
      T2ml1 <- T2mp[l-1]
      T3ml1 <- T3mp[l-1]
      
      M1l1 <- M1p[l-1]
      
      
      
      # Predict mediator
      dM1p <- data.frame(Vp, A = am, Al1 = am, Al2 = am, M1l1, M1l2, T1l1 = T1ml1, T1l2 = T1ml2, 
                         T2l1 = T2ml1, T2l2 = T2ml2, T3l1 = T3ml1, T3l2 = T3ml2,
                         jj = as.numeric((l-mean_j)/sd_j))
      
      if (M1p[l - 1] == 0) {
        # M1p[l] <- pFunc(fitR[[1]], dM1p)
        M1p[l] <- rFunc(fitR[[1]], dM1p)
      } else {
        M1p[l] <- 1
      }
      
      
      
      # Predict time-varying covariates (contribute to mediator models)
      # T1
      dT1mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1,T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T1mp[l] <- pFunc(fitR[[3]], dT1mp)
      
      # T2
      dT2mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2, 
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T2mp[l] <- predict(fitR[[4]], dT2mp)
      
      # T3
      dT3mp <- data.frame(Vp, A = am, Al1 = am, Al2 = am, 
                          M1 = M1p[l], M1l1, M1l2,
                          T1l1 = T1ml1, T1l2 = T1ml2, 
                          T2l1 = T2ml1, T2l2 = T2ml2, 
                          T3l1 = T3ml1, T3l2 = T3ml2,
                          jj = as.numeric((l-mean_j)/sd_j))
      T3mp[l] <- predict(fitR[[5]], dT3mp)
      
      
      # Predict time-varying covariates (contribute to outcome models, if ay != am)
      # If ay = am ==> simply covariates take the same values between two models
      
      if (ay != am) {
        # T1
        dT1p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T1p[l] <- pFunc(fitR[[3]], dT1p)
        
        # T2
        dT2p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T2p[l] <- predict(fitR[[4]], dT2p)
        
        # T3
        dT3p <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, 
                           M1 = M1p[l], M1l1, M1l2, 
                           T1l1, T1l2, 
                           T2l1, T2l2,  
                           T3l1, T3l2, 
                           jj = as.numeric((l-mean_j)/sd_j))
        T3p[l] <- predict(fitR[[5]], dT3p)
        
        
        
      } else {
        T1p[l] <- T1mp[l]
        T2p[l] <- T2mp[l]
        T3p[l] <- T3mp[l]
      }
      
      # Y
      dYp <- data.frame(Vp, A = ay, Al1 = ay, Al2 = ay, M1 = M1p[l], M1l1, M1l2, 
                        T1 = T1p[l], T1l1, T1l2, 
                        T2 = T2p[l], T2l1, T2l2,
                        T3 = T3p[l], T3l1, T3l2, 
                        jj = as.numeric((l-mean_j)/sd_j))
      Yp[l] <- pFunc(fitR[[2]], dYp)
      
    } else {
      break
    }
    
    mm[l] <- l
    
  }
  
  
  boot_num <- seed
  gdat <- data.frame(boot_num, id, id_ori, mm, Ay = ay, Am = am, M1p, Yp,
                     T1mp, T1p, T2mp, T2p, T3mp, T3p, Vp)
  gdat$lastid <- as.numeric(!duplicated(gdat$id, fromLast = T))
  return(gdat)
}
```

## Process data function

::: columns
::: {.column width="50%"}
```{r}
dat <- dat0 |> 
    group_by(id) |>
    mutate(
      A_lag1 = lag(Ap, n = 1, default = 0),
      A_lag2 = lag(Ap, n = 2, default = 0),
      M_lag1 = lag(Mp, n = 1, default = 0),
      M_lag2 = lag(Mp, n = 2, default = 0),
      L1_lag1 = lag(L1, n = 1, default = 0),
      L1_lag2 = lag(L1, n = 2, default = 0),
      L2_lag1 = lag(L2, n = 1, default = 100),
      L2_lag2 = lag(L2, n = 2, default = 100),
      L3_lag1 = lag(L3, n = 1, default = 80),
      L3_lag2 = lag(L3, n = 2, default = 80)
    ) |> ungroup() %>% df_prep()

dat %>% head()
```
:::

::: {.column width="50%"}
```{r}
data_pro <- process_data(
    fix = c("age","sex","ow","risk"),
    expo = c("Ap"),
    med = c("Mp"),
    tvar = c("L1","L2","L3"),
    outc = c("Yp"),
    lag = 2,
    time = c("mm"),
    data = dat0
  ) 

data_pro$df %>% head()
```
:::
:::

```{r}
test_that("process_data function", {
  ## id, v1 - v4
  expect_equal(dat[,c(1:5)],data_pro$df[,c(1:5)])
  
  ## exposure variables
  expect_equal(dat[,c("A")],data_pro$df[,c("A1")])
  expect_equal(dat[,c("Al1")],data_pro$df[,c("A1l1")])
  expect_equal(dat[,c("Al2")],data_pro$df[,c("A1l2")])
  
  ## time-dependent covariate
  expect_equal(dat[,c("T1")],data_pro$df[,c("L1")])
  expect_equal(dat[,c("T2")],data_pro$df[,c("L2")])
  expect_equal(dat[,c("T3")],data_pro$df[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(dat[,c("T1l1")],data_pro$df[,c("L1l1")])
  expect_equal(dat[,c("T2l1")],data_pro$df[,c("L2l1")])
  expect_equal(dat[,c("T3l1")],data_pro$df[,c("L3l1")])

  expect_equal(dat[,c("T1l2")],data_pro$df[,c("L1l2")])
  expect_equal(dat[,c("T2l2")],data_pro$df[,c("L2l2")])
  expect_equal(dat[,c("T3l2")],data_pro$df[,c("L3l2")])

  ## Mediator
  expect_equal(dat[,c("M1")],data_pro$df[,c("M1")])
  expect_equal(dat[,c("M1l1")],data_pro$df[,c("M1l1")])
  expect_equal(dat[,c("M1l2")],data_pro$df[,c("M1l2")])

  ## outcome and time
  expect_equal(dat[,c("Y","j")],data_pro$df[,c("Y","j")])
  
})
```

## fitg function

### seed = 0, no bootstrap

::: columns
::: {.column width="50%"}
```{r}

df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

boot <- df

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)

#----- fit parametric models for
#--- Mediator models

mM1 <- function(k){
  fitM1 <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitM1)
}

# PseudoR2(fitM1)
#--- Covariate models

mT1 <- function(k){
  fitT1 <- glm(T1 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitT1)
}

# PseudoR2(fitT1)

mT2 <- function(k){
  fitT2 <- lm(T2 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT2)
}

mT3 <- function(k){
  fitT3 <- lm(T3 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT3)
}

# Outcome model: E(Y|a, m, l, v)

mY <- function(k) {
  fitY <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
              family = binomial, data = boot)
  return(fitY)
}

# PseudoR2(fitY)

# Fit all models and save in a list
mR <- c(mM1, mY, mT1, mT2, mT3)
fitR <- lapply(1:5,function(x) mR[[x]](k))
```
:::

::: {.column width="50%"}
```{r}
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(boot=F,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) 
```
:::
:::

```{r}
test_that("fitg function", {

  ## model M(t)
  expect_equal(min(fitR[[1]]$fitted.values),min(fitR2$M[[1]]$fitted.values))
  expect_equal(max(fitR[[1]]$fitted.values),max(fitR2$M[[1]]$fitted.values))
  expect_equal(mean(fitR[[1]]$fitted.values),mean(fitR2$M[[1]]$fitted.values))
  expect_equal(sd(fitR[[1]]$fitted.values),sd(fitR2$M[[1]]$fitted.values))

  ## model Y
  expect_equal(min(fitR[[2]]$fitted.values),min(fitR2$Y$fitted.values))
  expect_equal(max(fitR[[2]]$fitted.values),max(fitR2$Y$fitted.values))
  expect_equal(mean(fitR[[2]]$fitted.values),mean(fitR2$Y$fitted.values))
  expect_equal(sd(fitR[[2]]$fitted.values),sd(fitR2$Y$fitted.values))
  
  ## model L1
  expect_equal(min(fitR[[3]]$fitted.values),min(fitR2$L[[1]]$fitted.values))
  expect_equal(max(fitR[[3]]$fitted.values),max(fitR2$L[[1]]$fitted.values))
  expect_equal(mean(fitR[[3]]$fitted.values),mean(fitR2$L[[1]]$fitted.values))
  expect_equal(sd(fitR[[3]]$fitted.values),sd(fitR2$L[[1]]$fitted.values))
  
  ## model L2
  expect_equal(min(fitR[[4]]$fitted.values),min(fitR2$L[[2]]$fitted.values))
  expect_equal(max(fitR[[4]]$fitted.values),max(fitR2$L[[2]]$fitted.values))
  expect_equal(mean(fitR[[4]]$fitted.values),mean(fitR2$L[[2]]$fitted.values))
  expect_equal(sd(fitR[[4]]$fitted.values),sd(fitR2$L[[2]]$fitted.values))
  
  ## model L3
  expect_equal(min(fitR[[5]]$fitted.values),min(fitR2$L[[3]]$fitted.values))
  expect_equal(max(fitR[[5]]$fitted.values),max(fitR2$L[[3]]$fitted.values))
  expect_equal(mean(fitR[[5]]$fitted.values),mean(fitR2$L[[3]]$fitted.values))
  expect_equal(sd(fitR[[5]]$fitted.values),sd(fitR2$L[[3]]$fitted.values))
})
```

### seed != 0, bootstrap

::: columns
::: {.column width="50%"}
```{r}
## seed = 123
df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

set.seed(123)

clusters <- names(table(df$id))
index <- sample(1:length(clusters), length(clusters), replace = TRUE)
bb <- table(clusters[index])

boot <- NULL

for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)

#----- fit parametric models for
#--- Mediator models

mM1 <- function(k){
  fitM1 <- glm(M1 ~ A + Al1 + Al2 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitM1)
}

# PseudoR2(fitM1)
#--- Covariate models

mT1 <- function(k){
  fitT1 <- glm(T1 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                 v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
               family = binomial, data = boot)
  return(fitT1)
}

# PseudoR2(fitT1)

mT2 <- function(k){
  fitT2 <- lm(T2 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT2)
}

mT3 <- function(k){
  fitT3 <- lm(T3 ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1l1 + T1l2 + T2l1 + T2l2 + T3l1 + T3l2 + 
                v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), data = boot)
  return(fitT3)
}

# Outcome model: E(Y|a, m, l, v)

mY <- function(k) {
  fitY <- glm(Y ~ A + Al1 + Al2 + M1 + M1l1 + M1l2 + T1 + T1l1 + T1l2 + T2 + T2l1 + T2l2 + 
                T3 + T3l1 + T3l2 +  v1 + v2 + v3 + v4 + splines::bs(jj, df = 3), 
              family = binomial, data = boot)
  return(fitY)
}

# PseudoR2(fitY)

# Fit all models and save in a list
mR <- c(mM1, mY, mT1, mT2, mT3)
fitR <- lapply(1:5,function(x) mR[[x]](k))
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) 
```
:::
:::

```{r}
test_that("fitg function", {

  ## model M(t)
  expect_equal(min(fitR[[1]]$fitted.values),min(fitR2$M[[1]]$fitted.values))
  expect_equal(max(fitR[[1]]$fitted.values),max(fitR2$M[[1]]$fitted.values))
  expect_equal(mean(fitR[[1]]$fitted.values),mean(fitR2$M[[1]]$fitted.values))
  expect_equal(sd(fitR[[1]]$fitted.values),sd(fitR2$M[[1]]$fitted.values))

  ## model Y
  expect_equal(min(fitR[[2]]$fitted.values),min(fitR2$Y$fitted.values))
  expect_equal(max(fitR[[2]]$fitted.values),max(fitR2$Y$fitted.values))
  expect_equal(mean(fitR[[2]]$fitted.values),mean(fitR2$Y$fitted.values))
  expect_equal(sd(fitR[[2]]$fitted.values),sd(fitR2$Y$fitted.values))
  
  ## model L1
  expect_equal(min(fitR[[3]]$fitted.values),min(fitR2$L[[1]]$fitted.values))
  expect_equal(max(fitR[[3]]$fitted.values),max(fitR2$L[[1]]$fitted.values))
  expect_equal(mean(fitR[[3]]$fitted.values),mean(fitR2$L[[1]]$fitted.values))
  expect_equal(sd(fitR[[3]]$fitted.values),sd(fitR2$L[[1]]$fitted.values))
  
  ## model L2
  expect_equal(min(fitR[[4]]$fitted.values),min(fitR2$L[[2]]$fitted.values))
  expect_equal(max(fitR[[4]]$fitted.values),max(fitR2$L[[2]]$fitted.values))
  expect_equal(mean(fitR[[4]]$fitted.values),mean(fitR2$L[[2]]$fitted.values))
  expect_equal(sd(fitR[[4]]$fitted.values),sd(fitR2$L[[2]]$fitted.values))
  
  ## model L3
  expect_equal(min(fitR[[5]]$fitted.values),min(fitR2$L[[3]]$fitted.values))
  expect_equal(max(fitR[[5]]$fitted.values),max(fitR2$L[[3]]$fitted.values))
  expect_equal(mean(fitR[[5]]$fitted.values),mean(fitR2$L[[3]]$fitted.values))
  expect_equal(sd(fitR[[5]]$fitted.values),sd(fitR2$L[[3]]$fitted.values))
})
```

## baseline_mc function

::: columns
::: {.column width="50%"}
```{r}
## seed = 123
df <- dat0 |> 
  group_by(id) |>
  mutate(
    A_lag1 = lag(Ap, n = 1, default = 0),
    A_lag2 = lag(Ap, n = 2, default = 0),
    M_lag1 = lag(Mp, n = 1, default = 0),
    M_lag2 = lag(Mp, n = 2, default = 0),
    L1_lag1 = lag(L1, n = 1, default = 0),
    L1_lag2 = lag(L1, n = 2, default = 0),
    L2_lag1 = lag(L2, n = 1, default = 100),
    L2_lag2 = lag(L2, n = 2, default = 100),
    L3_lag1 = lag(L3, n = 1, default = 80),
    L3_lag2 = lag(L3, n = 2, default = 80)
  ) |> ungroup() %>% df_prep()

set.seed(123)

clusters <- names(table(df$id))
index <- sample(1:length(clusters), length(clusters), replace = TRUE)
bb <- table(clusters[index])

boot <- NULL

for(zzz in 1:max(bb)) {
      # Loop over repeated id
      cc <- df[df$id %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$id, zzz)
      boot <- rbind(boot, cc)
    }

boot$jj <- scale(boot$j)
mean_j <- attributes(boot$jj)$`scaled:center`
sd_j <- attributes(boot$jj)$`scaled:scale`
boot$jj <- as.numeric(boot$jj)


montecarlo = 10000
# Select baseline visit
  df0 <- boot[boot$j==1, ]
  
  df0$idn <- 1:nrow(df0)
  
  MC <- NULL
  
    samples <- sample(df0$idn, size = montecarlo, replace = T)
    bb <- table(samples)
    
    for(zzz in 1:max(bb)) {
      cc <- df0[df0$idn %in% names(bb[bb %in% c(zzz:max(bb))]), ]
      cc$bid <- paste0(cc$idn, zzz)
      MC <- rbind(MC, cc)
    }
    
    MC$idsim <- 1:montecarlo
    
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
fitR2 <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)
```
:::
:::

```{r}
along_redf <- MC %>% as.data.frame()
test_redf <- fitR2$res_df %>% as.data.frame()

test_that("baseline_mc function", {

  # id, v1 - v4
  expect_equal(along_redf[,1],test_redf[,1])
  expect_equal(along_redf[,2],test_redf[,2])
  expect_equal(along_redf[,3],test_redf[,3])
  expect_equal(along_redf[,4],test_redf[,4])
  expect_equal(along_redf[,5],test_redf[,5])
  
  # exposure variables
  expect_equal(along_redf[,c("A")],test_redf[,c("A1")])
  expect_equal(along_redf[,c("Al1")],test_redf[,c("A1l1")])
  expect_equal(along_redf[,c("Al2")],test_redf[,c("A1l2")])

  ## time-dependent covariate
  expect_equal(along_redf[,c("T1")],test_redf[,c("L1")])
  expect_equal(along_redf[,c("T2")],test_redf[,c("L2")])
  expect_equal(along_redf[,c("T3")],test_redf[,c("L3")])

  ## time-dependent covariate + lag
  expect_equal(along_redf[,c("T1l1")],test_redf[,c("L1l1")])
  expect_equal(along_redf[,c("T2l1")],test_redf[,c("L2l1")])
  expect_equal(along_redf[,c("T3l1")],test_redf[,c("L3l1")])

  expect_equal(along_redf[,c("T1l2")],test_redf[,c("L1l2")])
  expect_equal(along_redf[,c("T2l2")],test_redf[,c("L2l2")])
  expect_equal(along_redf[,c("T3l2")],test_redf[,c("L3l2")])

  ## Mediator
  expect_equal(along_redf[,c("M1")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("M1l1")],test_redf[,c("M1l1")])
  expect_equal(along_redf[,c("M1l2")],test_redf[,c("M1l2")])

  ## outcome and time
  expect_equal(along_redf[,c("Y")],test_redf[,c("Y")])
  expect_equal(along_redf[,c("j")],test_redf[,c("j")])
})
```

## g_form function

### ay = 1, am = 1

::: columns
::: {.column width="50%"}
```{r}
seed = 123
set.seed(seed)
along_redf <- gform(ii = 1, pgdat = MC, length = 12, ay = 1, am = 1) %>% 
  as.data.frame()
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 1, length = 12, ay = 1, am = 1) %>% data.frame()
```
:::
:::

```{r}
test_that("gform function", {

  # boot_num - Am
  expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
  expect_equal(along_redf[,c("v1","v2","v3","v4","lastid")],
               test_redf[,c("v1","v2","v3","v4","lastid")])

  expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
  expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
  expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
  expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
  expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
  expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
  expect_equal(along_redf[,c("Yp")], test_redf[,c("Yp2")])
})
```

### ay = 0, am = 0

::: columns
::: {.column width="50%"}
```{r}
seed = 123
set.seed(seed)
along_redf <- gform(ii = 2, pgdat = MC, length = 12, ay = 0, am = 0) %>% 
  as.data.frame()
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000) %>% 
  g_form(ii = 2, length = 12, ay = 0, am = 0) %>% data.frame()
```
:::
:::

```{r}
test_that("gform function", {

  # boot_num - Am
  expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
  expect_equal(along_redf[,c("v1","v2","v3","v4","lastid")],
               test_redf[,c("v1","v2","v3","v4","lastid")])

  expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
  expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
  expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
  expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
  expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
  expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
  expect_equal(along_redf[,c("Yp")], test_redf[,c("Yp2")])
})
```

### ay = 1, am = 0

::: columns
::: {.column width="50%"}
```{r}
seed = 123
set.seed(123)
along_redf <- gform(ii = 2, pgdat = MC, length = 12, ay = 1, am = 0) %>% 
  as.data.frame()
```
:::

::: {.column width="50%"}
```{r}
set.seed(123)
test_redf <- process_data(
  fix = c("age","sex","ow","risk"),
  expo = c("Ap"),
  med = c("Mp"),
  tvar = c("L1","L2","L3"),
  outc = c("Yp"),
  lag = 2,
  norev = c("Mp"),
  time = c("mm"),
  data = dat0
) %>% fitg(boot=T,
           mreg = "binomial",
           lreg = c("binomial","gaussian","gaussian"),
           yreg = "binomial",dof = 3) %>% 
  baseline_mc(montecarlo = 10000)  %>% 
  g_form(ii = 2, length = 12, ay = 1, am = 0) %>% data.frame()
```
:::
:::

```{r}
test_that("gform function", {

  # boot_num - Am
  expect_equal(along_redf[,c(2:6)],test_redf[,c(1:5)])
  expect_equal(along_redf[,c("v1","v2","v3","v4","lastid")],
               test_redf[,c("v1","v2","v3","v4","lastid")])

  expect_equal(along_redf[,c("M1p")],test_redf[,c("M1")])
  expect_equal(along_redf[,c("T1mp")],test_redf[,c("Lmp1")])
  expect_equal(along_redf[,c("T1p")],test_redf[,c("Lp1")])
  expect_equal(along_redf[,c("T2mp")],test_redf[,c("Lmp2")])
  expect_equal(along_redf[,c("T2p")],test_redf[,c("Lp2")])
  expect_equal(along_redf[,c("T3mp")],test_redf[,c("Lmp3")])
  expect_equal(along_redf[,c("T3p")], test_redf[,c("Lp3")])
  expect_equal(along_redf[,c("Yp")], test_redf[,c("Yp2")])
})
```

# Additional function

```{r}
ExtResult2 <- function(data) {
  Q11 <- data |> filter(lastid == 1 & Ay ==1 & Am ==1)
  Q10 <- data |> filter(lastid == 1 & Ay ==1 & Am ==0)
  Q00 <- data |> filter(lastid == 1 & Ay ==0 & Am ==0)
  
  qq <- data.frame(mQ11 = mean(Q11$Yp2),
                   mQ10 = mean(Q10$Yp2),
                   mQ00 = mean(Q00$Yp2))
  qq
}
```


```{r}
cal_ci <- function(data,ci = 0.95,boot = T){
  
  if (boot == F){
    resu <- NULL
  } else {
    qnt <- quantile(data, na.rm = TRUE, probs = c((1-ci)/2,1 - (1-ci)/2))
    resu <- paste0("(",round(qnt[1],3),",",round(qnt[2],3),")")
  }
  resu
}
```

# Final tvmedg function

```{r}
tvmedg <- function(data,
                   fix,expo,med,tvar,lag,outc,time,norev = NULL,LM = FALSE,
                   boot = FALSE, seed = 0,
                   mreg = "binomial",
                   lreg = c("binomial","gaussian","gaussian"),
                   yreg = "binomial",dof = 3,
                   montecarlo = 10000,length = 12,parallel=TRUE,nboot = 1,ci = .95){
  
  set.seed(seed)
  
  start_time <- Sys.time()
  
  qqq <- matrix(ncol = 3) %>% data.frame()
  colnames(qqq) <- c("mQ11","mQ10","mQ00")
  
  qqq_ci <- matrix(ncol = 3) %>% data.frame()
  colnames(qqq_ci) <- c("mQ11","mQ10","mQ00")
  
  
  ## point estimate
  
  fitR2 <- process_data(
    fix = fix,
    expo = expo,
    med = med,
    tvar = tvar,
    outc = outc,
    lag = lag,
    time = time,
    norev = norev,
    LM = LM,
    data = data
  )  %>% 
    fitg(boot=boot,
         mreg = mreg,
         lreg = lreg,
         yreg = yreg,dof = dof) %>% 
    baseline_mc(montecarlo = montecarlo)
  
  if (parallel == TRUE){
    
    gform_wrapper2 <- function(iii, data, length) {
      outdat11 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 1)
      outdat10 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 0)
      outdat00 <- g_form(ii = iii,data=data, length = length, ay = 0, am = 0)
      bind_rows(outdat11, outdat10, outdat00)
    }
    
    resultDatM <- future_map_dfr(1:montecarlo,  
                                 ~ gform_wrapper2(ii = .x, data = fitR2, length = length))
  } else {
    resultDatM <- data.frame()
    for (iii in 1:montecarlo){
      outdat11 <- g_form(ii = iii,data=fitR2, length = length, ay = 1, am = 1)
      outdat10 <- g_form(ii = iii,data=fitR2, length = length, ay = 1, am = 0)
      outdat00 <- g_form(ii = iii,data=fitR2, length = length, ay = 0, am = 0)
      resultDatM2 <- rbind(outdat11, outdat10, outdat00)
      resultDatM <- rbind(resultDatM,resultDatM2)
    }
  }
  
  qqq <- ExtResult2(resultDatM) %>% mutate(
    rIE_b = mQ11 - mQ10,
    rDE_b = mQ10 - mQ00,
    rTE_b = mQ11 - mQ00,
    rPE_b = rIE_b/ rTE_b
  )
  
  if (boot == TRUE){
    
    for (it in 1:nboot){
      
      ## boostrap
      fitR2a <- process_data(
        fix = fix,
        expo = expo,
        med = med,
        tvar = tvar,
        outc = outc,
        lag = lag,
        time = time,
        norev = norev,
        LM = LM,
        data = data
      )  %>% 
        fitg(boot=boot,
             mreg = mreg,
             lreg = lreg,
             yreg = yreg,dof = dof) %>% 
        baseline_mc(montecarlo = montecarlo)
      
      ## extract mean of q11,q10,q00 of the ith iter
      if (parallel == TRUE){
        
        gform_wrapper2 <- function(iii, data, length) {
          outdat11 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 1)
          outdat10 <- g_form(ii = iii,data=data, length = length, ay = 1, am = 0)
          outdat00 <- g_form(ii = iii,data=data, length = length, ay = 0, am = 0)
          bind_rows(outdat11, outdat10, outdat00)
        }
        
        resultDatM_ci <- future_map_dfr(1:montecarlo,  
                                        ~ gform_wrapper2(ii = .x, data = fitR2a, length = length))
      } else {
        resultDatM <- data.frame()
        for (iii in 1:montecarlo){
          outdat11 <- g_form(ii = iii,data=fitR2a, length = length, ay = 1, am = 1)
          outdat10 <- g_form(ii = iii,data=fitR2a, length = length, ay = 1, am = 0)
          outdat00 <- g_form(ii = iii,data=fitR2a, length = length, ay = 0, am = 0)
          resultDatM2_ci <- rbind(outdat11, outdat10, outdat00)
          resultDatM_ci <- rbind(resultDatM_ci,resultDatM2_ci)
        }
      }
      
      qqq_ci[it,] <- ExtResult2(resultDatM_ci)
    }
    
    qqq_ci <- qqq_ci %>% mutate(
      rIE_b = mQ11 - mQ10,
      rDE_b = mQ10 - mQ00,
      rTE_b = mQ11 - mQ00,
      rPE_b = rIE_b/ rTE_b
    )
    
  }
  
  
  end_time <- Sys.time()
  elapsed_time <- end_time - start_time
  
  obj <- list()
  
  obj$ori_df <- fitR2$df
  obj$dat_MC <- resultDatM
  class(obj) <- "tvmedg"
  
  ## print result
  cat("Q(1,1):", round(qqq$mQ11, 3),cal_ci(qqq_ci$mQ11,ci,boot = boot),'\n')
  cat("Q(1,0):", round(qqq$mQ10, 3),cal_ci(qqq_ci$mQ10,ci,boot = boot),'\n')
  cat("Q(0,0):", round(qqq$mQ00, 3),cal_ci(qqq_ci$mQ00,ci,boot = boot),'\n')
  
  cat("Indirect:", round(qqq$rIE_b, 3),cal_ci(qqq_ci$rIE_b,ci,boot = boot),'\n')
  cat("Direct:", round(qqq$rDE_b, 3),cal_ci(qqq_ci$rDE_b,ci,boot = boot),'\n')
  cat("Total:", round(qqq$rTE_b, 3),cal_ci(qqq_ci$rTE_b,ci,boot = boot),'\n')
  cat("Proportional explain:", 
      round(qqq$rPE_b, 3),cal_ci(qqq_ci$rPE_b,ci,boot = boot),'\n')
  
  cat("Total time elapsed:",elapsed_time,attr(elapsed_time,"units"),'\n')
  
  invisible(obj)

}
```

## Run

```{r}
library(furrr)
library(doParallel)

cl <- makeCluster(8)
registerDoParallel(cl)

```

## lag = 2, M before L, bootstrap

```{r}
tvmedg(data = dat0,
       fix = c("age","sex","ow","risk"),
       expo = c("Ap"),
       med = c("Mp"),
       tvar = c("L1","L2","L3"),
       outc = c("Yp"),
       lag = 2,
       norev = c("Mp"),
       time = c("mm"),
       LM = F,
       boot = T,
       seed = 123,
       mreg = "binomial",
       lreg = c("binomial","gaussian","gaussian"),
       yreg = "binomial",dof = 3,
       montecarlo = 10,length = 12,
       parallel=TRUE,nboot = 2,ci=.95)
```

## lag = 3, L before M, no bootstrap

```{r}
tvmedg(data = dat0,
       fix = c("age","sex","ow","risk"),
       expo = c("Ap"),
       med = c("Mp"),
       tvar = c("L1","L2","L3"),
       outc = c("Yp"),
       lag = 3,
       norev = c("Mp"),
       time = c("mm"),
       LM = T,
       boot = F,
       seed = 123,
       mreg = "binomial",
       lreg = c("binomial","gaussian","gaussian"),
       yreg = "binomial",dof = 3,
       montecarlo = 5,length = 12,
       parallel=TRUE,nboot = 2,ci=.95)
```

# Plot function

```{r}
mytheme <- function(...) {
  theme_minimal() +
    theme(
      plot.title = element_text(size = 14,color = "grey10",  face = "bold", hjust = 0.5),
      axis.line = element_line(linetype = "solid"),
      axis.text = element_text(color = "gray10", size = 10),
      axis.title = element_text(color = "gray10", size = 12),
      # plot.background = element_blank(),
      panel.background = element_rect(fill = "white", color = NA),
      legend.title = element_text(size = 12, face = "bold"),
      legend.direction = "horizontal",
      legend.position = "top",
      legend.background = element_rect(fill = NA, color = NA),
      legend.text = element_text(size = 12),
      legend.key.width = unit(1, "line"),
      strip.text = element_text(size = 12, face = "bold"),
      strip.background = element_rect(fill = NA, color = NA)
    )
}
```

```{r}
plot.tvmedg <- function(x,what = c("all","cumY","tvY"),...){
  
  tv_cumsum <- x$ori_df |>
    group_by(j) |>
    summarise(
      y_prop = mean(Y),
      y_count = sum(Y)
    ) |> 
    ungroup() |>
    mutate(y_prob_cum = cumsum(y_count)/nrow(x$ori_df))
  
  dat1M <- x$dat_MC |> 
    mutate(group = if_else(Ay == 1 & Am == 1, "Q(1,1)",
                           if_else(Ay == 1 & Am ==0, "Q(1,0)", "Q(0,0)")),
           group = factor(group, labels = c("Q(0,0)", "Q(1,0)", "Q(1,1)")),
           groupM = factor(Am, label = c("No", "Yes"))) |> 
    group_by(group, mm) |>
    summarise(Y = mean(Yp2)) |>
    ungroup() |>
    group_by(group) |>
    mutate(Ysum = cumsum(Y))|>
    ungroup() 
  
  ## cumY
  
  cumy_dfplot <- dat1M |> 
    left_join(tv_cumsum, by = join_by(mm == j))
  
  y_limt <- max(cumy_dfplot$Ysum,cumy_dfplot$y_prob_cum,na.rm = T)
  
  f_cumY <- cumy_dfplot |>
    ggplot() +
    geom_line(aes(x = mm, y = Ysum, color = group), linewidth = 1) +
    geom_line(aes(x = mm, y = y_prob_cum), color = "gray20", 
              linewidth = 1, linetype = 2) +
    scale_color_brewer(palette = "Set1", direction = -1) +
    scale_y_continuous(limits = c(0, round(y_limt+0.4,1))) +
    scale_x_continuous(breaks = seq(0, max(dat1M$mm), by = 12)) +
    mytheme() +
    labs(x = "Month",
         y = "%",
         title = "Cumulative Y (%)",
         caption = "The dashed line represents the observed %",
         color = NULL)
  
  ## tvY
  tvy_dfplot <- dat1M |> 
    left_join(tv_cumsum, by = join_by(mm == j))
  
  y_limt2 <- max(tvy_dfplot$Y,tvy_dfplot$y_prop,na.rm=TRUE)
  
  f_tvY <- tvy_dfplot |>
    ggplot() +
    geom_line(aes(x = mm, y = Y, color = group), linewidth = 1) +
    geom_line(aes(x = mm, y = y_prop), color = "gray20", 
              linewidth = 1, linetype = 2) +
    scale_color_brewer(palette = "Set1", direction = -1) +
    scale_y_continuous(limits = c(0, round(y_limt2+0.02,1))) +
    scale_x_continuous(breaks = seq(0, max(dat1M$mm), by = 12)) +
    mytheme() +
    labs(x = "Month",
         y = "%",
         title = "Y by month (%)",
         caption = "The dashed line represents the observed %",
         color = NULL)
  
  if (what == c("all")){
    out_plot <- plot_grid(f_cumY,f_tvY,nrow = 1)
  } else if (what == "cumY") {
    out_plot <- f_cumY
  } else {
    out_plot <- f_tvY
  }
  
  out_plot
  
}
```

# Final run

```{r}
library(cowplot)
op <- tvmedg(data = dat0,
       fix = c("age","sex","ow","risk"),
       expo = c("Ap"),
       med = c("Mp"),
       tvar = c("L1","L2","L3"),
       outc = c("Yp"),
       lag = 2,
       norev = c("Mp"),
       time = c("mm"),
       LM = F,
       boot = T,
       seed = 123,
       mreg = "binomial",
       lreg = c("binomial","gaussian","gaussian"),
       yreg = "binomial",dof = 3,
       montecarlo = 1000,length = 12,
       parallel=TRUE,nboot = 5,ci=.95)


```

```{r}
#| out-width: "100%"

plot(op,"all")
plot(op,"cumY")
plot(op,"tvY")
```




